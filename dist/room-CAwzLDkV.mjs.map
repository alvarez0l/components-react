{"version":3,"file":"room-CAwzLDkV.mjs","sources":["../src/hooks/internal/useResizeObserver.ts","../src/hooks/internal/useObservableState.ts","../src/hooks/internal/useMediaQuery.ts","../src/hooks/useAudioPlayback.ts","../node_modules/clsx/dist/clsx.mjs","../src/mergeProps.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useConnectionQualityIndicator.ts","../src/hooks/useConnectionStatus.ts","../src/hooks/useDataChannel.ts","../src/hooks/useDisconnectButton.ts","../src/hooks/useFacingMode.ts","../src/hooks/useFocusToggle.ts","../src/hooks/useGridLayout.ts","../src/hooks/useIsMuted.ts","../src/hooks/useIsSpeaking.ts","../src/utils.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useLocalParticipant.ts","../src/hooks/useLocalParticipantPermissions.ts","../src/hooks/useMediaDeviceSelect.ts","../src/hooks/useMediaDevices.ts","../src/hooks/useVisualStableUpdate.ts","../src/hooks/usePagination.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useParticipantTile.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/usePinnedTracks.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useStartAudio.ts","../src/hooks/useStartVideo.ts","../src/hooks/useSwipe.ts","../src/hooks/useChatToggle.ts","../src/hooks/useToken.ts","../src/hooks/useTrackMutedIndicator.ts","../src/hooks/useTrackToggle.ts","../src/hooks/useTracks.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useChat.ts","../src/hooks/usePersistentUserChoices.ts","../src/hooks/useIsEncrypted.ts","../src/hooks/useTrackVolume.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\r\n/* eslint-disable no-underscore-dangle */\r\nimport * as React from 'react';\r\n\r\nconst useLatest = <T>(current: T) => {\r\n  const storedValue = React.useRef(current);\r\n  React.useEffect(() => {\r\n    storedValue.current = current;\r\n  });\r\n  return storedValue;\r\n};\r\n\r\n/**\r\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\r\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\r\n *\r\n * @internal\r\n */\r\nexport function useResizeObserver<T extends HTMLElement>(\r\n  target: React.RefObject<T>,\r\n  callback: UseResizeObserverCallback,\r\n) {\r\n  const resizeObserver = getResizeObserver();\r\n  const storedCallback = useLatest(callback);\r\n\r\n  React.useLayoutEffect(() => {\r\n    let didUnsubscribe = false;\r\n\r\n    const targetEl = target.current;\r\n    if (!targetEl) return;\r\n\r\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\r\n      if (didUnsubscribe) return;\r\n      storedCallback.current(entry, observer);\r\n    }\r\n\r\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\r\n\r\n    return () => {\r\n      didUnsubscribe = true;\r\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\r\n    };\r\n  }, [target.current, resizeObserver, storedCallback]);\r\n\r\n  return resizeObserver?.observer;\r\n}\r\n\r\nfunction createResizeObserver() {\r\n  let ticking = false;\r\n  let allEntries: ResizeObserverEntry[] = [];\r\n\r\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\r\n\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\r\n    allEntries = allEntries.concat(entries);\r\n    if (!ticking) {\r\n      window.requestAnimationFrame(() => {\r\n        const triggered = new Set<Element>();\r\n        for (let i = 0; i < allEntries.length; i++) {\r\n          if (triggered.has(allEntries[i].target)) continue;\r\n          triggered.add(allEntries[i].target);\r\n          const cbs = callbacks.get(allEntries[i].target);\r\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\r\n        }\r\n        allEntries = [];\r\n        ticking = false;\r\n      });\r\n    }\r\n    ticking = true;\r\n  });\r\n\r\n  return {\r\n    observer,\r\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      observer.observe(target);\r\n      const cbs = callbacks.get(target) ?? [];\r\n      cbs.push(callback);\r\n      callbacks.set(target, cbs);\r\n    },\r\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\r\n      const cbs = callbacks.get(target) ?? [];\r\n      if (cbs.length === 1) {\r\n        observer.unobserve(target);\r\n        callbacks.delete(target);\r\n        return;\r\n      }\r\n      const cbIndex = cbs.indexOf(callback);\r\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\r\n      callbacks.set(target, cbs);\r\n    },\r\n  };\r\n}\r\n\r\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\r\n\r\nconst getResizeObserver = () =>\r\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\r\n\r\nexport type UseResizeObserverCallback = (\r\n  entry: ResizeObserverEntry,\r\n  observer: ResizeObserver,\r\n) => unknown;\r\n\r\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\r\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\r\n  React.useLayoutEffect(() => {\r\n    if (target.current) {\r\n      const { width, height } = target.current.getBoundingClientRect();\r\n      setSize({ width, height });\r\n    }\r\n  }, [target.current]);\r\n\r\n  const resizeCallback = React.useCallback(\r\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\r\n    [],\r\n  );\r\n  // Where the magic happens\r\n  useResizeObserver(target, resizeCallback);\r\n  return size;\r\n};\r\n","import * as React from 'react';\r\n// @ts-ignore\r\nimport type { Observable } from 'rxjs';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useObservableState<T>(\r\n  observable: Observable<T> | undefined,\r\n  startWith: T,\r\n  resetWhenObservableChanges = true,\r\n) {\r\n  const [state, setState] = React.useState<T>(startWith);\r\n  React.useEffect(() => {\r\n    if (resetWhenObservableChanges) {\r\n      setState(startWith);\r\n    }\r\n    // observable state doesn't run in SSR\r\n    if (typeof window === 'undefined' || !observable) return;\r\n    const subscription = observable.subscribe(setState);\r\n    return () => subscription.unsubscribe();\r\n  }, [observable, resetWhenObservableChanges]);\r\n  return state;\r\n}\r\n","import * as React from 'react';\r\n/**\r\n * Implementation used from https://github.com/juliencrn/usehooks-ts\r\n *\r\n * @internal\r\n */\r\nexport function useMediaQuery(query: string): boolean {\r\n  const getMatches = (query: string): boolean => {\r\n    // Prevents SSR issues\r\n    if (typeof window !== 'undefined') {\r\n      return window.matchMedia(query).matches;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\r\n\r\n  function handleChange() {\r\n    setMatches(getMatches(query));\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    const matchMedia = window.matchMedia(query);\r\n\r\n    // Triggered at the first client-side load and if query changes\r\n    handleChange();\r\n\r\n    // Listen matchMedia\r\n    if (matchMedia.addListener) {\r\n      matchMedia.addListener(handleChange);\r\n    } else {\r\n      matchMedia.addEventListener('change', handleChange);\r\n    }\r\n\r\n    return () => {\r\n      if (matchMedia.removeListener) {\r\n        matchMedia.removeListener(handleChange);\r\n      } else {\r\n        matchMedia.removeEventListener('change', handleChange);\r\n      }\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [query]);\r\n\r\n  return matches;\r\n}\r\n","import type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\r\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\r\n * `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useAudioPlayback(room?: Room): {\r\n  canPlayAudio: boolean;\r\n  startAudio: () => Promise<void>;\r\n} {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const startAudio = React.useCallback(async () => {\r\n    await roomEnsured.startAudio();\r\n  }, [roomEnsured]);\r\n\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  return { canPlayAudio, startAudio };\r\n}\r\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */\r\n\r\nimport clsx from 'clsx';\r\n\r\n/**\r\n * Calls all functions in the order they were chained with the same arguments.\r\n * @internal\r\n */\r\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\r\n  return (...args: any[]) => {\r\n    for (const callback of callbacks) {\r\n      if (typeof callback === 'function') {\r\n        try {\r\n          callback(...args);\r\n        } catch (e) {\r\n          console.error(e);\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\ninterface Props {\r\n  [key: string]: any;\r\n}\r\n\r\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\r\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? V : never;\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n  ? I\r\n  : never;\r\n\r\n/**\r\n * Merges multiple props objects together. Event handlers are chained,\r\n * classNames are combined, and ids are deduplicated - different ids\r\n * will trigger a side-effect and re-render components hooked up with `useId`.\r\n * For all other props, the last prop object overrides all previous ones.\r\n * @param args - Multiple sets of props to merge together.\r\n * @internal\r\n */\r\nexport function mergeProps<T extends Props[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\r\n  // Start with a base clone of the first argument. This is a lot faster than starting\r\n  // with an empty object and adding properties as we go.\r\n  const result: Props = { ...args[0] };\r\n  for (let i = 1; i < args.length; i++) {\r\n    const props = args[i];\r\n    for (const key in props) {\r\n      const a = result[key];\r\n      const b = props[key];\r\n\r\n      // Chain events\r\n      if (\r\n        typeof a === 'function' &&\r\n        typeof b === 'function' &&\r\n        // This is a lot faster than a regex.\r\n        key[0] === 'o' &&\r\n        key[1] === 'n' &&\r\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\r\n        key.charCodeAt(2) <= /* 'Z' */ 90\r\n      ) {\r\n        result[key] = chain(a, b);\r\n\r\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\r\n      } else if (\r\n        (key === 'className' || key === 'UNSAFE_className') &&\r\n        typeof a === 'string' &&\r\n        typeof b === 'string'\r\n      ) {\r\n        result[key] = clsx(a, b);\r\n      } else {\r\n        result[key] = b !== undefined ? b : a;\r\n      }\r\n    }\r\n  }\r\n\r\n  return result as UnionToIntersection<TupleTypes<T>>;\r\n}\r\n","import { setupClearPinButton } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport type { ClearPinButtonProps } from '../components';\r\n\r\n/**\r\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\r\n * or your custom implementation of it component. It adds the `onClick` handler\r\n * to signal the `LayoutContext` that the tile in focus should be cleared.\r\n * @public\r\n */\r\nexport function useClearPinButton(props: ClearPinButtonProps) {\r\n  const { state, dispatch } = useLayoutContext().pin;\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className } = setupClearPinButton();\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      disabled: !state?.length,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'clear_pin' });\r\n      },\r\n    });\r\n    return mergedProps;\r\n  }, [props, dispatch, state]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport { ConnectionQuality } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface ConnectionQualityIndicatorOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/**\r\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\r\n * @example\r\n * ```tsx\r\n * const { quality } = useConnectionQualityIndicator();\r\n * // or\r\n * const { quality } = useConnectionQualityIndicator({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\r\n  const p = useEnsureParticipant(options.participant);\r\n\r\n  const { className, connectionQualityObserver } = React.useMemo(\r\n    () => setupConnectionQualityIndicator(p),\r\n    [p],\r\n  );\r\n\r\n  const quality = useObservableState(connectionQualityObserver, ConnectionQuality.Unknown);\r\n\r\n  return { className, quality };\r\n}\r\n","import { connectionStateObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const connectionState = useConnectionState(room);\r\n * ```\r\n * @public\r\n */\r\nexport function useConnectionState(room?: Room) {\r\n  // passed room takes precedence, if not supplied get current room context\r\n  const r = useEnsureRoom(room);\r\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\r\n  const connectionState = useObservableState(observable, r.state);\r\n  return connectionState;\r\n}\r\n","import type { ReceivedDataMessage } from '@livekit/components-core';\r\nimport { setupDataMessageHandler } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { DataPublishOptions } from 'livekit-client';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\r\n  isSending: boolean;\r\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\r\n  message: ReceivedDataMessage<T> | undefined;\r\n};\r\n\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * By optionally passing a `topic`, you can narrow down which messages are returned in the messages array.\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants via the 'chat' topic.\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n * @public\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topic: T,\r\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\r\n): UseDataChannelReturnType<T>;\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n * @public\r\n */\r\nexport function useDataChannel(\r\n  onMessage?: (msg: ReceivedDataMessage) => void,\r\n): UseDataChannelReturnType;\r\n/**\r\n * @internal\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\r\n  callback?: (msg: ReceivedDataMessage<T>) => void,\r\n) {\r\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\r\n\r\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\r\n  const room = useRoomContext();\r\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\r\n    () => setupDataMessageHandler(room, topic, onMessage),\r\n    [room, topic, onMessage],\r\n  );\r\n\r\n  const message = useObservableState(messageObservable, undefined);\r\n  const isSending = useObservableState(isSendingObservable, false);\r\n\r\n  return {\r\n    message,\r\n    send,\r\n    isSending,\r\n  };\r\n}\r\n","import { setupDisconnectButton } from '@livekit/components-core';\r\nimport { ConnectionState } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { DisconnectButtonProps } from '../components';\r\nimport { useRoomContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useConnectionState } from './useConnectionStatus';\r\n\r\n/**\r\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\r\n * custom implementation of it. It adds onClick handler to the button to disconnect\r\n * from the room.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { buttonProps } = useDisconnectButton(buttonProps);\r\n * return <button {...buttonProps}>Disconnect</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useDisconnectButton(props: DisconnectButtonProps) {\r\n  const room = useRoomContext();\r\n  const connectionState = useConnectionState(room);\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className, disconnect } = setupDisconnectButton(room);\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      onClick: () => disconnect(props.stopTracks ?? true),\r\n      disabled: connectionState === ConnectionState.Disconnected,\r\n    });\r\n    return mergedProps;\r\n  }, [room, props, connectionState]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\r\n\r\n/**\r\n * Try to determine the `facingMode` of a local participant video track.\r\n * @remarks\r\n * Works only on local video tracks.\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\r\n * @alpha\r\n */\r\nexport function useFacingMode(\r\n  trackReference: TrackReferenceOrPlaceholder,\r\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\r\n  if (trackReference.publication instanceof LocalTrackPublication) {\r\n    const localTrack = trackReference.publication.track;\r\n    if (localTrack) {\r\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\r\n      return facingMode;\r\n    }\r\n  }\r\n  return 'undefined';\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\r\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseFocusToggleProps {\r\n  trackRef?: TrackReferenceOrPlaceholder;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\r\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\r\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const layoutContext = useMaybeLayoutContext();\r\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\r\n\r\n  const inFocus: boolean = React.useMemo(() => {\r\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\r\n  }, [trackReference, layoutContext?.pin.state]);\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\r\n          // Call user defined on click callbacks.\r\n          props.onClick?.(event);\r\n\r\n          // Set or clear focus based on current focus state.\r\n          if (inFocus) {\r\n            layoutContext?.pin.dispatch?.({\r\n              msg: 'clear_pin',\r\n            });\r\n          } else {\r\n            layoutContext?.pin.dispatch?.({\r\n              msg: 'set_pin',\r\n              trackReference,\r\n            });\r\n          }\r\n        },\r\n      }),\r\n    [props, className, trackReference, inFocus, layoutContext?.pin],\r\n  );\r\n\r\n  return { mergedProps, inFocus };\r\n}\r\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\r\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useSize } from './internal';\r\n\r\n/**\r\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\r\n * If the available screen space is not enough, it will reduce the number of maximum visible\r\n * tiles and select a layout that still works visually within the given limitations.\r\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\r\n * while trying to display important tiles such as speaking participants or screen shares.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { layout } = useGridLayout(gridElement, trackCount);\r\n * ```\r\n * @public\r\n */\r\nexport function useGridLayout(\r\n  /** HTML element that contains the grid. */\r\n  gridElement: React.RefObject<HTMLDivElement>,\r\n  /** Count of tracks that should get layed out */\r\n  trackCount: number,\r\n  options: {\r\n    gridLayouts?: GridLayoutDefinition[];\r\n  } = {},\r\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\r\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\r\n  const { width, height } = useSize(gridElement);\r\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\r\n\r\n  React.useEffect(() => {\r\n    if (gridElement.current && layout) {\r\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\r\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\r\n    }\r\n  }, [gridElement, layout]);\r\n\r\n  return {\r\n    layout,\r\n    containerWidth: width,\r\n    containerHeight: height,\r\n  };\r\n}\r\n","import {\r\n  type TrackReferenceOrPlaceholder,\r\n  getTrackReferenceId,\r\n  mutedObserver,\r\n} from '@livekit/components-core';\r\nimport type { Participant, Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\n\r\n/** @public */\r\nexport interface UseIsMutedOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/**\r\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\r\n * It returns a `boolean` that indicates if the track is muted or not.\r\n *\r\n * @example With a track reference\r\n * ```tsx\r\n * const isMuted = useIsMuted(track);\r\n * ```\r\n *\r\n * @example With a track source / participant\r\n * ```tsx\r\n * const isMuted = useIsMuted('camera', { participant });\r\n * ```\r\n *\r\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\r\n * @param options - Additional options when using a `Track.Source`\r\n * @returns boolean indicating if the track is muted\r\n *\r\n * @public\r\n */\r\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\r\nexport function useIsMuted(\r\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\r\n  options: UseIsMutedOptions = {},\r\n) {\r\n  const passedParticipant =\r\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\r\n  const p = useEnsureParticipant(passedParticipant);\r\n  const ref =\r\n    typeof sourceOrTrackRef === 'string'\r\n      ? { participant: p, source: sourceOrTrackRef }\r\n      : sourceOrTrackRef;\r\n  const [isMuted, setIsMuted] = React.useState(\r\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\r\n    return () => listener.unsubscribe();\r\n  }, [getTrackReferenceId(ref)]);\r\n\r\n  return isMuted;\r\n}\r\n","import { createIsSpeakingObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\r\n * @example\r\n * ```tsx\r\n * const isSpeaking = useIsSpeaking(participant);\r\n * ```\r\n * @public\r\n */\r\nexport function useIsSpeaking(participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\r\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\r\n\r\n  return isSpeaking;\r\n}\r\n","import * as React from 'react';\r\nimport { mergeProps as mergePropsReactAria } from './mergeProps';\r\nimport { log } from '@livekit/components-core';\r\nimport clsx from 'clsx';\r\n\r\n/** @internal */\r\nexport function isProp<U extends HTMLElement, T extends React.HTMLAttributes<U>>(\r\n  prop: T | undefined,\r\n): prop is T {\r\n  return prop !== undefined;\r\n}\r\n\r\n/** @internal */\r\nexport function mergeProps<\r\n  U extends HTMLElement,\r\n  T extends Array<React.HTMLAttributes<U> | undefined>,\r\n>(...props: T) {\r\n  return mergePropsReactAria(...props.filter(isProp));\r\n}\r\n\r\n/** @internal */\r\nexport function cloneSingleChild(\r\n  children: React.ReactNode | React.ReactNode[],\r\n  props?: Record<string, any>,\r\n  key?: any,\r\n) {\r\n  return React.Children.map(children, (child) => {\r\n    // Checking isValidElement is the safe way and avoids a typescript\r\n    // error too.\r\n    if (React.isValidElement(child) && React.Children.only(children)) {\r\n      if (child.props.class) {\r\n        // make sure we retain classnames of both passed props and child\r\n        props ??= {};\r\n        props.class = clsx(child.props.class, props.class);\r\n        props.style = { ...child.props.style, ...props.style };\r\n      }\r\n      return React.cloneElement(child, { ...props, key });\r\n    }\r\n    return child;\r\n  });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function warnAboutMissingStyles(el?: HTMLElement) {\r\n  if (\r\n    typeof window !== 'undefined' &&\r\n    typeof process !== 'undefined' &&\r\n    // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n    (process?.env?.NODE_ENV === 'dev' ||\r\n      // eslint-disable-next-line turbo/no-undeclared-env-vars\r\n      process?.env?.NODE_ENV === 'development')\r\n  ) {\r\n    const target = el ?? document.querySelector('.lk-room-container');\r\n    if (target && !getComputedStyle(target).getPropertyValue('--lk-has-imported-styles')) {\r\n      log.warn(\r\n        \"It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page.\",\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @internal\r\n * used to stringify room options to detect dependency changes for react hooks.\r\n * Replaces processors and e2ee options with strings.\r\n */\r\nexport function roomOptionsStringifyReplacer(key: string, val: unknown) {\r\n  if (key === 'processor' && val && typeof val === 'object' && 'name' in val) {\r\n    return val.name;\r\n  }\r\n  if (key === 'e2ee' && val) {\r\n    return 'e2ee-enabled';\r\n  }\r\n  return val;\r\n}\r\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\r\nimport type { DisconnectReason } from 'livekit-client';\r\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { HTMLAttributes } from 'react';\r\n\r\nimport type { LiveKitRoomProps } from '../components';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { roomOptionsStringifyReplacer } from '../utils';\r\n\r\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\r\n  connect: true,\r\n  audio: false,\r\n  video: false,\r\n};\r\n\r\n/**\r\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\r\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { room, htmlProps } = useLiveKitRoom();\r\n * return <div {...htmlProps}>...</div>;\r\n * ```\r\n * @public\r\n */\r\nexport function useLiveKitRoom<T extends HTMLElement>(\r\n  props: LiveKitRoomProps,\r\n): {\r\n  room: Room | undefined;\r\n  htmlProps: HTMLAttributes<T>;\r\n} {\r\n  const {\r\n    token,\r\n    serverUrl,\r\n    options,\r\n    room: passedRoom,\r\n    connectOptions,\r\n    connect,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMediaDeviceFailure,\r\n    onEncryptionError,\r\n    simulateParticipants,\r\n    ...rest\r\n  } = { ...defaultRoomProps, ...props };\r\n  if (options && passedRoom) {\r\n    log.warn(\r\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\r\n    );\r\n  }\r\n\r\n  const [room, setRoom] = React.useState<Room | undefined>();\r\n\r\n  const shouldConnect = React.useRef(connect);\r\n\r\n  React.useEffect(() => {\r\n    setRoom(passedRoom ?? new Room(options));\r\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\r\n\r\n  const htmlProps = React.useMemo(() => {\r\n    const { className } = setupLiveKitRoom();\r\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\r\n  }, [rest]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    const onSignalConnected = () => {\r\n      const localP = room.localParticipant;\r\n\r\n      log.debug('trying to publish local tracks');\r\n      Promise.all([\r\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\r\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\r\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\r\n      ]).catch((e) => {\r\n        log.warn(e);\r\n        onError?.(e as Error);\r\n      });\r\n    };\r\n\r\n    const handleMediaDeviceError = (e: Error) => {\r\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\r\n      onMediaDeviceFailure?.(mediaDeviceFailure);\r\n    };\r\n    const handleEncryptionError = (e: Error) => {\r\n      onEncryptionError?.(e);\r\n    };\r\n    const handleDisconnected = (reason?: DisconnectReason) => {\r\n      onDisconnected?.(reason);\r\n    };\r\n    const handleConnected = () => {\r\n      onConnected?.();\r\n    };\r\n\r\n    room\r\n      .on(RoomEvent.SignalConnected, onSignalConnected)\r\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\r\n      .on(RoomEvent.Disconnected, handleDisconnected)\r\n      .on(RoomEvent.Connected, handleConnected);\r\n\r\n    return () => {\r\n      room\r\n        .off(RoomEvent.SignalConnected, onSignalConnected)\r\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\r\n        .off(RoomEvent.Disconnected, handleDisconnected)\r\n        .off(RoomEvent.Connected, handleConnected);\r\n    };\r\n  }, [\r\n    room,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onError,\r\n    onEncryptionError,\r\n    onMediaDeviceFailure,\r\n    onConnected,\r\n    onDisconnected,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n\r\n    if (simulateParticipants) {\r\n      room.simulateParticipants({\r\n        participants: {\r\n          count: simulateParticipants,\r\n        },\r\n        publish: {\r\n          audio: true,\r\n          useRealTracks: true,\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (connect) {\r\n      shouldConnect.current = true;\r\n      log.debug('connecting');\r\n      if (!token) {\r\n        log.debug('no token yet');\r\n        return;\r\n      }\r\n      if (!serverUrl) {\r\n        log.warn('no livekit url provided');\r\n        onError?.(Error('no livekit url provided'));\r\n        return;\r\n      }\r\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\r\n        log.warn(e);\r\n        if (shouldConnect.current === true) {\r\n          onError?.(e as Error);\r\n        }\r\n      });\r\n    } else {\r\n      log.debug('disconnecting because connect is false');\r\n      shouldConnect.current = false;\r\n      room.disconnect();\r\n    }\r\n  }, [\r\n    connect,\r\n    token,\r\n    JSON.stringify(connectOptions),\r\n    room,\r\n    onError,\r\n    serverUrl,\r\n    simulateParticipants,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    return () => {\r\n      log.info('disconnecting on onmount');\r\n      room.disconnect();\r\n    };\r\n  }, [room]);\r\n\r\n  return { room, htmlProps };\r\n}\r\n","import type { ParticipantMedia } from '@livekit/components-core';\r\nimport { observeParticipantMedia } from '@livekit/components-core';\r\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseLocalParticipantOptions {\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useLocalParticipant` hook returns the local participant and the associated state\r\n * around the participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { localParticipant } = useLocalParticipant();\r\n * ```\r\n * @public\r\n */\r\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\r\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\r\n    localParticipant.lastMicrophoneError,\r\n  );\r\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\r\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\r\n    localParticipant.isMicrophoneEnabled,\r\n  );\r\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\r\n    undefined,\r\n  );\r\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\r\n\r\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\r\n    setIsCameraEnabled(media.isCameraEnabled);\r\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\r\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\r\n    setCameraTrack(media.cameraTrack);\r\n    setMicrophoneTrack(media.microphoneTrack);\r\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\r\n    setLastCameraError(media.participant.lastCameraError);\r\n    setLocalParticipant(media.participant);\r\n  };\r\n  React.useEffect(() => {\r\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\r\n    // TODO also listen to permission and metadata etc. events\r\n    return () => listener.unsubscribe();\r\n  }, [room]);\r\n\r\n  return {\r\n    isMicrophoneEnabled,\r\n    isScreenShareEnabled,\r\n    isCameraEnabled,\r\n    microphoneTrack,\r\n    cameraTrack,\r\n    lastMicrophoneError,\r\n    lastCameraError,\r\n    localParticipant,\r\n  };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\r\n * ```\r\n * @public\r\n */\r\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\r\n  const room = useRoomContext();\r\n  const permissionObserver = React.useMemo(\r\n    () => participantPermissionObserver(room.localParticipant),\r\n    [room],\r\n  );\r\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\r\n  return permissions;\r\n}\r\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\r\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface UseMediaDeviceSelectProps {\r\n  kind: MediaDeviceKind;\r\n  room?: Room;\r\n  track?: LocalAudioTrack | LocalVideoTrack;\r\n  /**\r\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\r\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\r\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\r\n   * appropriate permissions.\r\n   *\r\n   * @see {@link MediaDeviceMenu}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\r\n   */\r\n  requestPermissions?: boolean;\r\n  /**\r\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\r\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\r\n   * Most commonly this will emit a MediaDeviceError\r\n   */\r\n  onError?: (e: Error) => void;\r\n}\r\n\r\n/**\r\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\r\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\r\n * and a function to set the the active device.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\r\n * ```\r\n * @public\r\n */\r\nexport function useMediaDeviceSelect({\r\n  kind,\r\n  room,\r\n  track,\r\n  requestPermissions,\r\n  onError,\r\n}: UseMediaDeviceSelectProps) {\r\n  const roomContext = useMaybeRoomContext();\r\n\r\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\r\n\r\n  // List of all devices.\r\n  const deviceObserver = React.useMemo(\r\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\r\n    [kind, requestPermissions, onError],\r\n  );\r\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\r\n  // Active device management.\r\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\r\n    roomFallback?.getActiveDevice(kind) ?? 'default',\r\n  );\r\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\r\n    () => setupDeviceSelector(kind, roomFallback),\r\n    [kind, roomFallback, track],\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\r\n      if (!deviceId) {\r\n        return;\r\n      }\r\n      log.info('setCurrentDeviceId', deviceId);\r\n      setCurrentDeviceId(deviceId);\r\n    });\r\n    return () => {\r\n      listener?.unsubscribe();\r\n    };\r\n  }, [activeDeviceObservable]);\r\n\r\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\r\n}\r\n","import * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { createMediaDeviceObserver } from '@livekit/components-core';\r\n\r\n/**\r\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\r\n *\r\n * @example\r\n * ```tsx\r\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\r\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\r\n * ```\r\n * @public\r\n */\r\nexport function useMediaDevices({\r\n  kind,\r\n  onError,\r\n}: {\r\n  kind: MediaDeviceKind;\r\n  onError?: (e: Error) => void;\r\n}) {\r\n  const deviceObserver = React.useMemo(\r\n    () => createMediaDeviceObserver(kind, onError),\r\n    [kind, onError],\r\n  );\r\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\r\n  return devices;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseVisualStableUpdateOptions {\r\n  /** Overwrites the default sort function. */\r\n  customSortFunction?: (\r\n    trackReferences: TrackReferenceOrPlaceholder[],\r\n  ) => TrackReferenceOrPlaceholder[];\r\n}\r\n\r\n/**\r\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\r\n * in an array. The algorithm only starts to update when there are more items than visually fit\r\n * on a page. If this is the case, it will make sure that speaking participants move to the first\r\n * page and are always visible.\r\n * @remarks\r\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\r\n * or start speaking.\r\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\r\n *\r\n * @example\r\n * ```tsx\r\n * const trackRefs = useTracks();\r\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\r\n * ```\r\n * @public\r\n */\r\nexport function useVisualStableUpdate(\r\n  /** `TrackReference`s to display in the grid.  */\r\n  trackReferences: TrackReferenceOrPlaceholder[],\r\n  maxItemsOnPage: number,\r\n  options: UseVisualStableUpdateOptions = {},\r\n): TrackReferenceOrPlaceholder[] {\r\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\r\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\r\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\r\n\r\n  const sortedTrackRefs =\r\n    typeof options.customSortFunction === 'function'\r\n      ? options.customSortFunction(trackReferences)\r\n      : sortTrackReferences(trackReferences);\r\n\r\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\r\n  if (layoutChanged === false) {\r\n    try {\r\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\r\n    } catch (error) {\r\n      log.error('Error while running updatePages(): ', error);\r\n    }\r\n  }\r\n\r\n  // Save info for to compare against in the next update cycle.\r\n  if (layoutChanged) {\r\n    lastTrackRefs.current = sortedTrackRefs;\r\n  } else {\r\n    lastTrackRefs.current = updatedTrackRefs;\r\n  }\r\n  lastMaxItemsOnPage.current = maxItemsOnPage;\r\n\r\n  return updatedTrackRefs;\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\r\n\r\n/**\r\n * The `usePagination` hook implements simple pagination logic for use with arrays.\r\n * @example\r\n * ```tsx\r\n * const tracks = useTracks();\r\n * const pagination = usePagination(4, tracks);\r\n *\r\n * <TrackLoop tracks={pagination.tracks} />\r\n * ```\r\n * @alpha\r\n */\r\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\r\n  const [currentPage, setCurrentPage] = React.useState(1);\r\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\r\n  if (currentPage > totalPageCount) {\r\n    setCurrentPage(totalPageCount);\r\n  }\r\n  const lastItemIndex = currentPage * itemPerPage;\r\n  const firstItemIndex = lastItemIndex - itemPerPage;\r\n\r\n  const changePage = (direction: 'next' | 'previous') => {\r\n    setCurrentPage((state) => {\r\n      if (direction === 'next') {\r\n        if (state === totalPageCount) {\r\n          return state;\r\n        }\r\n        return state + 1;\r\n      } else {\r\n        if (state === 1) {\r\n          return state;\r\n        }\r\n        return state - 1;\r\n      }\r\n    });\r\n  };\r\n\r\n  const goToPage = (num: number) => {\r\n    if (num > totalPageCount) {\r\n      setCurrentPage(totalPageCount);\r\n    } else if (num < 1) {\r\n      setCurrentPage(1);\r\n    } else {\r\n      setCurrentPage(num);\r\n    }\r\n  };\r\n\r\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\r\n\r\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\r\n\r\n  return {\r\n    totalPageCount,\r\n    nextPage: () => changePage('next'),\r\n    prevPage: () => changePage('previous'),\r\n    setPage: goToPage,\r\n    firstItemIndex,\r\n    lastItemIndex,\r\n    tracks: tracksOnPage,\r\n    currentPage,\r\n  };\r\n}\r\n\r\nexport default usePagination;\r\n","import { participantInfoObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { identity, name, metadata } = useParticipantInfo({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantInfoOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\r\n  let p = useMaybeParticipantContext();\r\n  if (props.participant) {\r\n    p = props.participant;\r\n  }\r\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\r\n  const { identity, name, metadata } = useObservableState(infoObserver, {\r\n    name: p?.name,\r\n    identity: p?.identity,\r\n    metadata: p?.metadata,\r\n  });\r\n\r\n  return { identity, name, metadata };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\n\r\n/**\r\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const permissions = useParticipantPermissions({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantPermissionsOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantPermissions(\r\n  options: UseParticipantPermissionsOptions = {},\r\n): ParticipantPermission | undefined {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\r\n  const permissions = useObservableState(permissionObserver, p.permissions);\r\n  return permissions;\r\n}\r\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport { setupParticipantTile } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureTrackRef } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useFacingMode } from './useFacingMode';\r\nimport { useIsMuted } from './useIsMuted';\r\nimport { useIsSpeaking } from './useIsSpeaking';\r\nimport { Track } from 'livekit-client';\r\n\r\n/** @public */\r\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\r\n  /** The track reference to display. */\r\n  trackRef?: TrackReferenceOrPlaceholder;\r\n  disableSpeakingIndicator?: boolean;\r\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\r\n  htmlProps: React.HTMLAttributes<T>;\r\n}\r\n\r\n/**\r\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\r\n * @remarks\r\n * The returned props include many data attributes that are useful for CSS styling purposes because they\r\n * indicate the state of the participant and the track.\r\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\r\n * @public\r\n */\r\nexport function useParticipantTile<T extends HTMLElement>({\r\n  trackRef,\r\n  onParticipantClick,\r\n  disableSpeakingIndicator,\r\n  htmlProps,\r\n}: UseParticipantTileProps<T>) {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const mergedProps = React.useMemo(() => {\r\n    const { className } = setupParticipantTile();\r\n    return mergeProps(htmlProps, {\r\n      className,\r\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\r\n        htmlProps.onClick?.(event);\r\n        if (typeof onParticipantClick === 'function') {\r\n          const track =\r\n            trackReference.publication ??\r\n            trackReference.participant.getTrackPublication(trackReference.source);\r\n          onParticipantClick({ participant: trackReference.participant, track });\r\n        }\r\n      },\r\n    });\r\n  }, [\r\n    htmlProps,\r\n    onParticipantClick,\r\n    trackReference.publication,\r\n    trackReference.source,\r\n    trackReference.participant,\r\n  ]);\r\n\r\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\r\n  const micRef = React.useMemo(() => {\r\n    return {\r\n      participant: trackReference.participant,\r\n      source: Track.Source.Microphone,\r\n      publication: micTrack,\r\n    };\r\n  }, [micTrack, trackReference.participant]);\r\n  const isVideoMuted = useIsMuted(trackReference);\r\n  const isAudioMuted = useIsMuted(micRef);\r\n  const isSpeaking = useIsSpeaking(trackReference.participant);\r\n  const facingMode = useFacingMode(trackReference);\r\n  return {\r\n    elementProps: {\r\n      'data-lk-audio-muted': isAudioMuted,\r\n      'data-lk-video-muted': isVideoMuted,\r\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\r\n      'data-lk-local-participant': trackReference.participant.isLocal,\r\n      'data-lk-source': trackReference.source,\r\n      'data-lk-facing-mode': facingMode,\r\n      ...mergedProps,\r\n    } as React.HTMLAttributes<T>,\r\n  };\r\n}\r\n","import { connectedParticipantsObserver } from '@livekit/components-core';\r\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useRemoteParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\r\n\r\n  React.useEffect(() => {\r\n    const listener = connectedParticipantsObserver(room, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n    }).subscribe(setParticipants);\r\n    return () => listener.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\r\n  return participants;\r\n}\r\n","import type { Room, RoomEvent } from 'livekit-client';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipants(options: UseParticipantsOptions = {}) {\r\n  const remoteParticipants = useRemoteParticipants(options);\r\n  const { localParticipant } = useLocalParticipant(options);\r\n\r\n  return React.useMemo(\r\n    () => [localParticipant, ...remoteParticipants],\r\n    [localParticipant, remoteParticipants],\r\n  );\r\n}\r\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { LayoutContextType } from '../context';\r\nimport { useEnsureLayoutContext } from '../context';\r\n\r\n/**\r\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\r\n * @remarks\r\n * To function properly, this hook must be called within a `LayoutContext`.\r\n * @example\r\n * ```tsx\r\n * const pinnedTracks = usePinnedTracks();\r\n * ```\r\n * @public\r\n */\r\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\r\n  layoutContext = useEnsureLayoutContext(layoutContext);\r\n  return React.useMemo(() => {\r\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\r\n      return layoutContext.pin.state;\r\n    }\r\n    return [];\r\n  }, [layoutContext.pin.state]);\r\n}\r\n","import {\r\n  type ParticipantIdentifier,\r\n  connectedParticipantObserver,\r\n  participantByIdentifierObserver,\r\n} from '@livekit/components-core';\r\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\r\n   */\r\n  updateOnlyOn?: ParticipantEvent[];\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identifier: ParticipantIdentifier,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant('Russ');\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identity: string,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\nexport function useRemoteParticipant(\r\n  identityOrIdentifier: string | ParticipantIdentifier,\r\n  options: UseRemoteParticipantOptions = {},\r\n): RemoteParticipant | undefined {\r\n  const room = useRoomContext();\r\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (typeof identityOrIdentifier === 'string') {\r\n      return connectedParticipantObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    } else {\r\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    }\r\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\r\n\r\n  // Using `wrapperParticipant` to ensure a new object reference,\r\n  // triggering a re-render when the participant events fire.\r\n  const [participantWrapper, setParticipantWrapper] = React.useState({\r\n    p: undefined as RemoteParticipant | undefined,\r\n  });\r\n  React.useEffect(() => {\r\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\r\n    return () => listener.unsubscribe();\r\n  }, [observable]);\r\n\r\n  return participantWrapper.p;\r\n}\r\n","import { roomInfoObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\r\n * @remarks\r\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { name, metadata } = useRoomInfo();\r\n * ```\r\n * @public\r\n */\r\nexport interface UseRoomInfoOptions {\r\n  room?: Room;\r\n}\r\n\r\n/** @public */\r\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\r\n  const { name, metadata } = useObservableState(infoObserver, {\r\n    name: room.name,\r\n    metadata: room.metadata,\r\n  });\r\n\r\n  return { name, metadata };\r\n}\r\n","import { activeSpeakerObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\r\n *\r\n * @example\r\n * ```tsx\r\n * const activeSpeakers = useSpeakingParticipants();\r\n * ```\r\n * @public\r\n */\r\nexport function useSpeakingParticipants() {\r\n  const room = useRoomContext();\r\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\r\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\r\n  return activeSpeakers;\r\n}\r\n","import { sortParticipants } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\r\n\r\n/**\r\n * The `useSortedParticipants` hook returns the participants sorted by importance.\r\n * @public\r\n */\r\nexport function useSortedParticipants(participants: Array<Participant>) {\r\n  const [sortedParticipants, setSortedParticipants] = React.useState(\r\n    sortParticipants(participants),\r\n  );\r\n  const activeSpeakers = useSpeakingParticipants();\r\n\r\n  React.useEffect(() => {\r\n    setSortedParticipants(sortParticipants(participants));\r\n  }, [activeSpeakers, participants]);\r\n  return sortedParticipants;\r\n}\r\n","import { setupStartAudio } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @alpha */\r\nexport interface UseStartAudioProps {\r\n  room?: Room;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\r\n * that indicates whether audio playback is allowed in the current context,\r\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\r\n    () => setupStartAudio(),\r\n    [],\r\n  );\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: () => {\r\n          handleStartAudioPlayback(roomEnsured);\r\n        },\r\n        style: { display: canPlayAudio ? 'none' : 'block' },\r\n      }),\r\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\r\n  );\r\n\r\n  return { mergedProps, canPlayAudio };\r\n}\r\n","import { setupStartVideo } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @alpha */\r\nexport interface UseStartVideoProps {\r\n  room?: Room;\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\r\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\r\n * that indicates whether video playback is allowed in the current context,\r\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\r\n *\r\n * @alpha\r\n */\r\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\r\n    () => setupStartVideo(),\r\n    [],\r\n  );\r\n  const observable = React.useMemo(\r\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\r\n  );\r\n  const { canPlayVideo } = useObservableState(observable, {\r\n    canPlayVideo: roomEnsured.canPlaybackVideo,\r\n  });\r\n\r\n  const mergedProps = React.useMemo(\r\n    () =>\r\n      mergeProps(props, {\r\n        className,\r\n        onClick: () => {\r\n          handleStartVideoPlayback(roomEnsured);\r\n        },\r\n        style: { display: canPlayVideo ? 'none' : 'block' },\r\n      }),\r\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\r\n  );\r\n\r\n  return { mergedProps, canPlayVideo };\r\n}\r\n","import * as React from 'react';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport type UseSwipeOptions = {\r\n  minSwipeDistance?: number;\r\n  onLeftSwipe?: () => void;\r\n  onRightSwipe?: () => void;\r\n};\r\n\r\n/**\r\n * Simple implementation to detect horizontal swipe actions.\r\n * Accepts callbacks for on right and left swipes.\r\n * @example\r\n * ```tsx\r\n *  <div\r\n      onTouchStart={onTouchStart}\r\n      onTouchMove={onTouchMove}\r\n      onTouchEnd={onTouchEnd}\r\n    >\r\n * ```\r\n * @alpha\r\n */\r\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\r\n  const touchStart = React.useRef<number | null>(null);\r\n  const touchEnd = React.useRef<number | null>(null);\r\n\r\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\r\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\r\n\r\n  const onTouchStart = (event: TouchEvent) => {\r\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\r\n    touchStart.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchMove = (event: TouchEvent) => {\r\n    touchEnd.current = event.targetTouches[0].clientX;\r\n  };\r\n\r\n  const onTouchEnd = React.useCallback(() => {\r\n    if (!touchStart.current || !touchEnd.current) {\r\n      return;\r\n    }\r\n    const distance = touchStart.current - touchEnd.current;\r\n    const isLeftSwipe = distance > minSwipeDistance;\r\n    const isRightSwipe = distance < -minSwipeDistance;\r\n\r\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\r\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\r\n  }, [minSwipeDistance, options]);\r\n\r\n  React.useEffect(() => {\r\n    const elementCopy = element.current;\r\n    if (elementCopy) {\r\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\r\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\r\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\r\n    }\r\n    return () => {\r\n      if (elementCopy) {\r\n        elementCopy.removeEventListener('touchstart', onTouchStart);\r\n        elementCopy.removeEventListener('touchmove', onTouchMove);\r\n        elementCopy.removeEventListener('touchend', onTouchEnd);\r\n      }\r\n    };\r\n  }, [element, onTouchEnd]);\r\n}\r\n","import { setupChatToggle } from '@livekit/components-core';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseChatToggleProps {\r\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\r\n}\r\n\r\n/**\r\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\r\n * @remarks\r\n * Depends on the `LayoutContext` to work properly.\r\n * @see {@link ChatToggle}, {@link Chat}\r\n * @public\r\n */\r\nexport function useChatToggle({ props }: UseChatToggleProps) {\r\n  const { dispatch, state } = useLayoutContext().widget;\r\n  const { className } = React.useMemo(() => setupChatToggle(), []);\r\n\r\n  const mergedProps = React.useMemo(() => {\r\n    return mergeProps(props, {\r\n      className,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\r\n      },\r\n      'aria-pressed': state?.showChat ? 'true' : 'false',\r\n      'data-lk-unread-msgs': state\r\n        ? state.unreadMessages < 10\r\n          ? state.unreadMessages.toFixed(0)\r\n          : '9+'\r\n        : '0',\r\n    });\r\n  }, [props, className, dispatch, state]);\r\n\r\n  return { mergedProps };\r\n}\r\n","import { log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UserInfo {\r\n  identity?: string;\r\n  name?: string;\r\n  metadata?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface UseTokenOptions {\r\n  userInfo?: UserInfo;\r\n}\r\n\r\n/**\r\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\r\n *\r\n * @example\r\n * ```tsx\r\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\r\n * ```\r\n * @public */\r\nexport function useToken(\r\n  tokenEndpoint: string | undefined,\r\n  roomName: string,\r\n  options: UseTokenOptions = {},\r\n) {\r\n  const [token, setToken] = React.useState<string | undefined>(undefined);\r\n\r\n  React.useEffect(() => {\r\n    if (tokenEndpoint === undefined) {\r\n      throw Error('token endpoint needs to be defined');\r\n    }\r\n    if (options.userInfo?.identity === undefined) {\r\n      return;\r\n    }\r\n    const tokenFetcher = async () => {\r\n      log.debug('fetching token');\r\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\r\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\r\n      if (!res.ok) {\r\n        log.error(\r\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\r\n        );\r\n        return;\r\n      }\r\n      const { accessToken } = await res.json();\r\n      setToken(accessToken);\r\n    };\r\n    tokenFetcher();\r\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\r\n  return token;\r\n}\r\n","import {\r\n  type TrackReferenceOrPlaceholder,\r\n  setupTrackMutedIndicator,\r\n  getTrackReferenceId,\r\n} from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureTrackRef } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ninterface TrackMutedIndicatorReturnType {\r\n  isMuted: boolean;\r\n  className: string;\r\n}\r\n\r\n/**\r\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\r\n * and returns the muted state of the given track.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { isMuted } = useTrackMutedIndicator(trackRef);\r\n * ```\r\n * @public\r\n */\r\nexport function useTrackMutedIndicator(\r\n  trackRef?: TrackReferenceOrPlaceholder,\r\n): TrackMutedIndicatorReturnType {\r\n  const trackReference = useEnsureTrackRef(trackRef);\r\n\r\n  const { className, mediaMutedObserver } = React.useMemo(\r\n    () => setupTrackMutedIndicator(trackReference),\r\n    [getTrackReferenceId(trackReference)],\r\n  );\r\n\r\n  const isMuted = useObservableState(\r\n    mediaMutedObserver,\r\n    !!(\r\n      trackReference.publication?.isMuted ||\r\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\r\n    ),\r\n  );\r\n\r\n  return { isMuted, className };\r\n}\r\n","import type { ToggleSource } from '@livekit/components-core';\r\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { TrackToggleProps } from '../components';\r\nimport { useMaybeRoomContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { useObservableState } from './internal';\r\n\r\n/** @public */\r\nexport interface UseTrackToggleProps<T extends ToggleSource>\r\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\r\n\r\n/**\r\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\r\n * and functionality of the given track.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\r\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\r\n * ```\r\n * @public\r\n */\r\nexport function useTrackToggle<T extends ToggleSource>({\r\n  source,\r\n  onChange,\r\n  initialState,\r\n  captureOptions,\r\n  publishOptions,\r\n  onDeviceError,\r\n  ...rest\r\n}: UseTrackToggleProps<T>) {\r\n  const room = useMaybeRoomContext();\r\n  const track = room?.localParticipant?.getTrackPublication(source);\r\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\r\n  const userInteractionRef = React.useRef(false);\r\n\r\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\r\n    () =>\r\n      room\r\n        ? setupMediaToggle<T>(source, room, captureOptions, publishOptions, onDeviceError)\r\n        : setupManualToggle(),\r\n    [room, source, JSON.stringify(captureOptions), publishOptions],\r\n  );\r\n\r\n  const pending = useObservableState(pendingObserver, false);\r\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\r\n\r\n  React.useEffect(() => {\r\n    onChange?.(enabled, userInteractionRef.current);\r\n    userInteractionRef.current = false;\r\n  }, [enabled, onChange]);\r\n\r\n  React.useEffect(() => {\r\n    if (initialState !== undefined) {\r\n      log.debug('forcing initial toggle state', source, initialState);\r\n      toggle(initialState);\r\n    }\r\n    // only execute once at the beginning\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\r\n\r\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\r\n    (evt) => {\r\n      userInteractionRef.current = true;\r\n      toggle().catch(() => (userInteractionRef.current = false));\r\n      rest.onClick?.(evt);\r\n    },\r\n    [rest, toggle],\r\n  );\r\n\r\n  return {\r\n    toggle,\r\n    enabled,\r\n    pending,\r\n    track,\r\n    buttonProps: {\r\n      ...newProps,\r\n      'aria-pressed': enabled,\r\n      'data-lk-source': source,\r\n      'data-lk-enabled': enabled,\r\n      disabled: pending,\r\n      onClick: clickHandler,\r\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\r\n  };\r\n}\r\n","import type {\r\n  SourcesArray,\r\n  TrackReference,\r\n  TrackReferenceOrPlaceholder,\r\n  TrackSourceWithOptions,\r\n  TrackReferencePlaceholder,\r\n} from '@livekit/components-core';\r\nimport {\r\n  isSourcesWithOptions,\r\n  isSourceWitOptions,\r\n  log,\r\n  trackReferencesObservable,\r\n} from '@livekit/components-core';\r\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\r\nimport { Track } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport type UseTracksOptions = {\r\n  updateOnlyOn?: RoomEvent[];\r\n  onlySubscribed?: boolean;\r\n  room?: Room;\r\n};\r\n\r\n/** @public */\r\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\r\n  ? TrackReference[]\r\n  : T extends TrackSourceWithOptions[]\r\n    ? TrackReferenceOrPlaceholder[]\r\n    : never;\r\n\r\n/**\r\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\r\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\r\n * @example\r\n * ```ts\r\n * // Return all camera track publications.\r\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\r\n * ```\r\n * @example\r\n * ```ts\r\n * // Return all subscribed camera tracks as well as placeholders for\r\n * // participants without a camera subscription.\r\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\r\n * ```\r\n * @public\r\n */\r\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\r\n  sources: T = [\r\n    Track.Source.Camera,\r\n    Track.Source.Microphone,\r\n    Track.Source.ScreenShare,\r\n    Track.Source.ScreenShareAudio,\r\n    Track.Source.Unknown,\r\n  ] as T,\r\n  options: UseTracksOptions = {},\r\n): UseTracksHookReturnType<T> {\r\n  const room = useEnsureRoom(options.room);\r\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\r\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\r\n\r\n  const sources_ = React.useMemo(() => {\r\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\r\n  }, [JSON.stringify(sources)]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackReferencesObservable(room, sources_, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n      onlySubscribed: options.onlySubscribed,\r\n    }).subscribe(({ trackReferences, participants }) => {\r\n      log.debug('setting track bundles', trackReferences, participants);\r\n      setTrackReferences(trackReferences);\r\n      setParticipants(participants);\r\n    });\r\n    return () => subscription.unsubscribe();\r\n  }, [\r\n    room,\r\n    JSON.stringify(options.onlySubscribed),\r\n    JSON.stringify(options.updateOnlyOn),\r\n    JSON.stringify(sources),\r\n  ]);\r\n\r\n  const maybeTrackReferences = React.useMemo(() => {\r\n    if (isSourcesWithOptions(sources)) {\r\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\r\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\r\n        Array.from(trackReferences);\r\n      participants.forEach((participant) => {\r\n        if (requirePlaceholder.has(participant.identity)) {\r\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\r\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\r\n            if (\r\n              trackReferences.find(\r\n                ({ participant: p, publication }) =>\r\n                  participant.identity === p.identity && publication.source === placeholderSource,\r\n              )\r\n            ) {\r\n              return;\r\n            }\r\n            log.debug(\r\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\r\n            );\r\n            const placeholder: TrackReferencePlaceholder = {\r\n              participant,\r\n              source: placeholderSource,\r\n            };\r\n            trackReferencesWithPlaceholders.push(placeholder);\r\n          });\r\n        }\r\n      });\r\n      return trackReferencesWithPlaceholders;\r\n    } else {\r\n      return trackReferences;\r\n    }\r\n  }, [trackReferences, participants, sources]);\r\n\r\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\r\n}\r\n\r\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\r\n  const _difference = new Set(setA);\r\n  for (const elem of setB) {\r\n    _difference.delete(elem);\r\n  }\r\n  return _difference;\r\n}\r\n\r\nexport function requiredPlaceholders<T extends SourcesArray>(\r\n  sources: T,\r\n  participants: Participant[],\r\n): Map<Participant['identity'], Track.Source[]> {\r\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\r\n  if (isSourcesWithOptions(sources)) {\r\n    const sourcesThatNeedPlaceholder = sources\r\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\r\n      .map((sourceWithOption) => sourceWithOption.source);\r\n\r\n    participants.forEach((participant) => {\r\n      const sourcesOfSubscribedTracks = participant\r\n        .getTrackPublications()\r\n        .map((pub) => pub.track?.source)\r\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\r\n      const placeholderNeededForThisParticipant = Array.from(\r\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\r\n      );\r\n      // If the participant needs placeholder add it to the placeholder map.\r\n      if (placeholderNeededForThisParticipant.length > 0) {\r\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\r\n      }\r\n    });\r\n  }\r\n  return placeholderMap;\r\n}\r\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\r\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { Track } from 'livekit-client';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackRefBySourceOrName(\r\n  source: TrackSource<Track.Source>,\r\n): TrackReferenceOrPlaceholder {\r\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\r\n\r\n  const { trackObserver } = React.useMemo(() => {\r\n    return setupMediaTrack(source);\r\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackObserver.subscribe((publication) => {\r\n      setPublication(publication);\r\n    });\r\n    return () => subscription?.unsubscribe();\r\n  }, [trackObserver]);\r\n\r\n  return {\r\n    participant: source.participant,\r\n    source: source.source ?? Track.Source.Unknown,\r\n    publication,\r\n  };\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\r\n\r\n/**\r\n * This function `useTrackByName` allows you to access a track by referencing its track name.\r\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\r\n * for both a passed participant argument and, if not available, a valid participant context.\r\n *\r\n * @public\r\n */\r\nexport function useTrackByName(name: string, participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useTrackRefBySourceOrName({ name, participant: p });\r\n}\r\n","import * as React from 'react';\r\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\r\nimport { setupChat } from '@livekit/components-core';\r\nimport { ConnectionState } from 'livekit-client';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\nimport { useConnectionState } from './useConnectionStatus';\r\n\r\n/**\r\n * The `useChat` hook provides chat functionality for a LiveKit room.\r\n *\r\n * @remarks\r\n * Message history is not persisted and will be lost if the component is refreshed.\r\n * You may want to persist message history in the browser, a cache or a database.\r\n *\r\n * @returns An object containing:\r\n * - `chatMessages` - Array of received chat messages\r\n * - `send` - Function to send a new message\r\n * - `isSending` - Boolean indicating if a message is currently being sent\r\n *\r\n * @example\r\n * ```tsx\r\n * function ChatComponent() {\r\n *   const { chatMessages, send, isSending } = useChat();\r\n *\r\n *   return (\r\n *     <div>\r\n *       {chatMessages.map((msg) => (\r\n *         <div key={msg.timestamp}>\r\n *           {msg.from?.identity}: {msg.message}\r\n *         </div>\r\n *       ))}\r\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\r\n *         Send Message\r\n *       </button>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n * @public\r\n */\r\nexport function useChat(options?: ChatOptions) {\r\n  const room = useRoomContext();\r\n  const connectionState = useConnectionState(room);\r\n  const isDisconnected = React.useMemo(\r\n    () => connectionState === ConnectionState.Disconnected,\r\n    [connectionState],\r\n  ); // used to reset the messages on room disconnect\r\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\r\n    () => setupChat(room, options),\r\n    [room, options, isDisconnected],\r\n  );\r\n  const isSending = useObservableState(setup.isSendingObservable, false);\r\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\r\n\r\n  return { send: setup.send, update: setup.update, chatMessages, isSending };\r\n}\r\n","import type { LocalUserChoices } from '@livekit/components-core';\r\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/**\r\n * Options for the `usePersistentDeviceSettings` hook.\r\n * @alpha\r\n */\r\nexport interface UsePersistentUserChoicesOptions {\r\n  /**\r\n   * The default value to use if reading from local storage returns no results or fails.\r\n   */\r\n  defaults?: Partial<LocalUserChoices>;\r\n  /**\r\n   * Whether to prevent saving to persistent storage.\r\n   * @defaultValue false\r\n   */\r\n  preventSave?: boolean;\r\n  /**\r\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\r\n   * @defaultValue false\r\n   */\r\n  preventLoad?: boolean;\r\n}\r\n\r\n/**\r\n * A hook that provides access to user choices stored in local storage, such as\r\n * selected media devices and their current state (on or off), as well as the user name.\r\n * @alpha\r\n */\r\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\r\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\r\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\r\n  );\r\n\r\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\r\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\r\n  }, []);\r\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\r\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\r\n  }, []);\r\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\r\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\r\n  }, []);\r\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\r\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\r\n  }, []);\r\n  const saveUsername = React.useCallback((username: string) => {\r\n    setSettings((prev) => ({ ...prev, username: username }));\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    saveUserChoices(userChoices, options.preventSave ?? false);\r\n  }, [userChoices, options.preventSave]);\r\n\r\n  return {\r\n    userChoices,\r\n    saveAudioInputEnabled,\r\n    saveVideoInputEnabled,\r\n    saveAudioInputDeviceId,\r\n    saveVideoInputDeviceId,\r\n    saveUsername,\r\n  };\r\n}\r\n","import * as React from 'react';\r\nimport { LocalParticipant } from 'livekit-client';\r\nimport type { Participant, Room } from 'livekit-client';\r\nimport { encryptionStatusObservable } from '@livekit/components-core';\r\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface UseIsEncryptedOptions {\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\r\n  const p = useEnsureParticipant(participant);\r\n\r\n  const room = useEnsureRoom(options.room);\r\n\r\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\r\n  const isEncrypted = useObservableState(\r\n    observer,\r\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\r\n  );\r\n  return isEncrypted;\r\n}\r\n","import * as React from 'react';\r\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\r\nimport { Track, createAudioAnalyser } from 'livekit-client';\r\nimport {\r\n  type TrackReference,\r\n  isTrackReference,\r\n  type TrackReferenceOrPlaceholder,\r\n} from '@livekit/components-core';\r\n\r\n/**\r\n * @alpha\r\n * Hook for tracking the volume of an audio track using the Web Audio API.\r\n */\r\nexport function useTrackVolume(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\r\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\r\n) {\r\n  const track = isTrackReference(trackOrTrackReference)\r\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\r\n    : trackOrTrackReference;\r\n  const [volume, setVolume] = React.useState(0);\r\n  React.useEffect(() => {\r\n    if (!track || !track.mediaStream) {\r\n      return;\r\n    }\r\n\r\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\r\n\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n\r\n    const updateVolume = () => {\r\n      analyser.getByteFrequencyData(dataArray);\r\n      let sum = 0;\r\n      for (let i = 0; i < dataArray.length; i++) {\r\n        const a = dataArray[i];\r\n        sum += a * a;\r\n      }\r\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\r\n    };\r\n\r\n    const interval = setInterval(updateVolume, 1000 / 30);\r\n\r\n    return () => {\r\n      cleanup();\r\n      clearInterval(interval);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\r\n\r\n  return volume;\r\n}\r\n\r\nconst normalizeFrequencies = (frequencies: Float32Array) => {\r\n  const normalizeDb = (value: number) => {\r\n    const minDb = -100;\r\n    const maxDb = -10;\r\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\r\n    db = Math.sqrt(db);\r\n\r\n    return db;\r\n  };\r\n\r\n  // Normalize all frequency values\r\n  return frequencies.map((value) => {\r\n    if (value === -Infinity) {\r\n      return 0;\r\n    }\r\n    return normalizeDb(value);\r\n  });\r\n};\r\n\r\n/**\r\n * Interface for configuring options for the useMultibandTrackVolume hook.\r\n * @alpha\r\n */\r\nexport interface MultiBandTrackVolumeOptions {\r\n  bands?: number;\r\n  /**\r\n   * cut off of frequency bins on the lower end\r\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\r\n   */\r\n  loPass?: number;\r\n  /**\r\n   * cut off of frequency bins on the higher end\r\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\r\n   */\r\n  hiPass?: number;\r\n  /**\r\n   * update should run every x ms\r\n   */\r\n  updateInterval?: number;\r\n  analyserOptions?: AnalyserOptions;\r\n}\r\n\r\nconst multibandDefaults = {\r\n  bands: 5,\r\n  loPass: 100,\r\n  hiPass: 600,\r\n  updateInterval: 32,\r\n  analyserOptions: { fftSize: 2048 },\r\n} as const satisfies MultiBandTrackVolumeOptions;\r\n\r\n/**\r\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\r\n * @alpha\r\n */\r\nexport function useMultibandTrackVolume(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\r\n  options: MultiBandTrackVolumeOptions = {},\r\n) {\r\n  const track =\r\n    trackOrTrackReference instanceof Track\r\n      ? trackOrTrackReference\r\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\r\n  const opts = { ...multibandDefaults, ...options };\r\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\r\n    new Array(opts.bands).fill(0),\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!track || !track?.mediaStream) {\r\n      return;\r\n    }\r\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\r\n\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Float32Array(bufferLength);\r\n\r\n    const updateVolume = () => {\r\n      analyser.getFloatFrequencyData(dataArray);\r\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\r\n      for (let i = 0; i < dataArray.length; i++) {\r\n        frequencies[i] = dataArray[i];\r\n      }\r\n      frequencies = frequencies.slice(options.loPass, options.hiPass);\r\n\r\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\r\n      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands); // we want logarithmic chunking here\r\n      const chunks: Array<number> = [];\r\n      for (let i = 0; i < opts.bands; i++) {\r\n        const summedVolumes = normalizedFrequencies\r\n          .slice(i * chunkSize, (i + 1) * chunkSize)\r\n          .reduce((acc, val) => (acc += val), 0);\r\n        chunks.push(summedVolumes / chunkSize);\r\n      }\r\n\r\n      setFrequencyBands(chunks);\r\n    };\r\n\r\n    const interval = setInterval(updateVolume, opts.updateInterval);\r\n\r\n    return () => {\r\n      cleanup();\r\n      clearInterval(interval);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\r\n\r\n  return frequencyBands;\r\n}\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface AudioWaveformOptions {\r\n  barCount?: number;\r\n  volMultiplier?: number;\r\n  updateInterval?: number;\r\n}\r\n\r\nconst waveformDefaults = {\r\n  barCount: 120,\r\n  volMultiplier: 5,\r\n  updateInterval: 20,\r\n} as const satisfies AudioWaveformOptions;\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport function useAudioWaveform(\r\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\r\n  options: AudioWaveformOptions = {},\r\n) {\r\n  const track =\r\n    trackOrTrackReference instanceof Track\r\n      ? trackOrTrackReference\r\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\r\n  const opts = { ...waveformDefaults, ...options };\r\n\r\n  const aggregateWave = React.useRef(new Float32Array());\r\n  const timeRef = React.useRef(performance.now());\r\n  const updates = React.useRef(0);\r\n  const [bars, setBars] = React.useState<number[]>([]);\r\n\r\n  const onUpdate = React.useCallback((wave: Float32Array) => {\r\n    setBars(\r\n      Array.from(\r\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\r\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\r\n      ),\r\n    );\r\n  }, []);\r\n\r\n  React.useEffect(() => {\r\n    if (!track || !track?.mediaStream) {\r\n      return;\r\n    }\r\n    const { analyser, cleanup } = createAudioAnalyser(track, {\r\n      fftSize: getFFTSizeValue(opts.barCount),\r\n    });\r\n\r\n    const bufferLength = getFFTSizeValue(opts.barCount);\r\n    const dataArray = new Float32Array(bufferLength);\r\n\r\n    const update = () => {\r\n      updateWaveform = requestAnimationFrame(update);\r\n      analyser.getFloatTimeDomainData(dataArray);\r\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\r\n      updates.current += 1;\r\n\r\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\r\n        const newData = dataArray.map((v) => v / updates.current);\r\n        onUpdate(newData);\r\n        timeRef.current = performance.now();\r\n        updates.current = 0;\r\n      }\r\n    };\r\n\r\n    let updateWaveform = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cleanup();\r\n      cancelAnimationFrame(updateWaveform);\r\n    };\r\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\r\n\r\n  return {\r\n    bars,\r\n  };\r\n}\r\n\r\nfunction getFFTSizeValue(x: number) {\r\n  if (x < 32) return 32;\r\n  else return pow2ceil(x);\r\n}\r\n\r\n// function sigmoid(x: number, k = 2, s = 0) {\r\n//   return 1 / (1 + Math.exp(-(x - s) / k));\r\n// }\r\n\r\nfunction pow2ceil(v: number) {\r\n  let p = 2;\r\n  while ((v >>= 1)) {\r\n    p <<= 1;\r\n  }\r\n  return p;\r\n}\r\n\r\nfunction filterData(audioData: Float32Array, numSamples: number) {\r\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\r\n  const filteredData = new Float32Array(numSamples);\r\n  for (let i = 0; i < numSamples; i++) {\r\n    const blockStart = blockSize * i; // the location of the first sample in the block\r\n    let sum = 0;\r\n    for (let j = 0; j < blockSize; j++) {\r\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\r\n    }\r\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\r\n  }\r\n  return filteredData;\r\n}\r\n\r\n// function normalizeData(audioData: Float32Array) {\r\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\r\n//   return audioData.map((n) => n * multiplier);\r\n// }\r\n","import * as React from 'react';\r\nimport type { TrackReference } from '@livekit/components-core';\r\nimport { participantTracksObservable } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\nimport type { Track } from 'livekit-client';\r\nimport { useMaybeParticipantContext, useRoomContext } from '../context';\r\n\r\n/**\r\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\r\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\r\n * @public\r\n */\r\nexport function useParticipantTracks(\r\n  sources: Track.Source[],\r\n  participantIdentity?: string,\r\n): TrackReference[] {\r\n  const room = useRoomContext();\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = participantIdentity\r\n    ? room.getParticipantByIdentity(participantIdentity)\r\n    : participantContext;\r\n  const observable = React.useMemo(\r\n    () => (p ? participantTracksObservable(p, { sources }) : undefined),\r\n    [p?.sid, p?.identity, JSON.stringify(sources)],\r\n  );\r\n\r\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\r\n\r\n  return trackRefs;\r\n}\r\n","import * as React from 'react';\r\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\r\n  const observable = React.useMemo(\r\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\r\n    [ref?.publication?.track],\r\n  );\r\n  return useObservableState(observable, {\r\n    timestamp: Date.now(),\r\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\r\n  });\r\n}\r\n","import {\r\n  type ReceivedTranscriptionSegment,\r\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\r\n  dedupeSegments,\r\n  // getActiveTranscriptionSegments,\r\n  getTrackReferenceId,\r\n  trackTranscriptionObserver,\r\n  type TrackReferenceOrPlaceholder,\r\n  // didActiveSegmentsChange,\r\n} from '@livekit/components-core';\r\nimport type { TranscriptionSegment } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useTrackSyncTime } from './useTrackSyncTime';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface TrackTranscriptionOptions {\r\n  /**\r\n   * how many transcription segments should be buffered in state\r\n   * @defaultValue 100\r\n   */\r\n  bufferSize?: number;\r\n  /**\r\n   * optional callback for retrieving newly incoming transcriptions only\r\n   */\r\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\r\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\r\n  // maxAge?: number;\r\n}\r\n\r\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\r\n  bufferSize: 100,\r\n  // maxAge: 2_000,\r\n} as const satisfies TrackTranscriptionOptions;\r\n\r\n/**\r\n * @returns An object consisting of `segments` with maximum length of opts.windowLength and `activeSegments` that are valid for the current track timestamp\r\n * @alpha\r\n */\r\nexport function useTrackTranscription(\r\n  trackRef: TrackReferenceOrPlaceholder | undefined,\r\n  options?: TrackTranscriptionOptions,\r\n) {\r\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\r\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\r\n  // const [activeSegments, setActiveSegments] = React.useState<Array<ReceivedTranscriptionSegment>>(\r\n  //   [],\r\n  // );\r\n  // const prevActiveSegments = React.useRef<ReceivedTranscriptionSegment[]>([]);\r\n  const syncTimestamps = useTrackSyncTime(trackRef);\r\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\r\n    opts.onTranscription?.(newSegments);\r\n    setSegments((prevSegments) =>\r\n      dedupeSegments(\r\n        prevSegments,\r\n        // when first receiving a segment, add the current media timestamp to it\r\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\r\n        opts.bufferSize,\r\n      ),\r\n    );\r\n  };\r\n  React.useEffect(() => {\r\n    if (!trackRef?.publication) {\r\n      return;\r\n    }\r\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\r\n      handleSegmentMessage(...evt);\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\r\n\r\n  // React.useEffect(() => {\r\n  //   if (syncTimestamps) {\r\n  //     const newActiveSegments = getActiveTranscriptionSegments(\r\n  //       segments,\r\n  //       syncTimestamps,\r\n  //       opts.maxAge,\r\n  //     );\r\n  //     // only update active segment array if content actually changed\r\n  //     if (didActiveSegmentsChange(prevActiveSegments.current, newActiveSegments)) {\r\n  //       setActiveSegments(newActiveSegments);\r\n  //       prevActiveSegments.current = newActiveSegments;\r\n  //     }\r\n  //   }\r\n  // }, [syncTimestamps, segments, opts.maxAge]);\r\n\r\n  return { segments };\r\n}\r\n","import { participantAttributesObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { attributes } = useParticipantAttributes({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantAttributesOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = props.participant ?? participantContext;\r\n  const attributeObserver = React.useMemo(\r\n    // weird typescript constraint\r\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\r\n    [p],\r\n  );\r\n  const attributeState = useObservableState(attributeObserver, {\r\n    attributes: p?.attributes,\r\n  });\r\n\r\n  return attributeState;\r\n}\r\n\r\n/**\r\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\r\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipantAttribute(\r\n  attributeKey: string,\r\n  options: UseParticipantAttributesOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\r\n\r\n  React.useEffect(() => {\r\n    if (!p) {\r\n      return;\r\n    }\r\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\r\n      if (val.changed[attributeKey] !== undefined) {\r\n        setAttribute(val.attributes[attributeKey]);\r\n      }\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [p, attributeKey]);\r\n\r\n  return attribute;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\r\nimport type { RemoteParticipant } from 'livekit-client';\r\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useTrackTranscription } from './useTrackTranscription';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useParticipantAttributes } from './useParticipantAttributes';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport type AgentState =\r\n  | 'disconnected'\r\n  | 'connecting'\r\n  | 'initializing'\r\n  | 'listening'\r\n  | 'thinking'\r\n  | 'speaking';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface VoiceAssistant {\r\n  agent: RemoteParticipant | undefined;\r\n  state: AgentState;\r\n  audioTrack: TrackReference | undefined;\r\n  agentTranscriptions: ReceivedTranscriptionSegment[];\r\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\r\n}\r\n\r\nconst state_attribute = 'lk.agent.state';\r\n\r\n/**\r\n * This hook looks for the first agent-participant in the room.\r\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\r\n * @example\r\n * ```tsx\r\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\r\n * ```\r\n * @beta\r\n */\r\nexport function useVoiceAssistant(): VoiceAssistant {\r\n  const agent = useRemoteParticipants().find((p) => p.kind === ParticipantKind.AGENT);\r\n  const audioTrack = useParticipantTracks([Track.Source.Microphone], agent?.identity)[0];\r\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\r\n  const connectionState = useConnectionState();\r\n  const { attributes } = useParticipantAttributes({ participant: agent });\r\n\r\n  const state: AgentState = React.useMemo(() => {\r\n    if (connectionState === ConnectionState.Disconnected) {\r\n      return 'disconnected';\r\n    } else if (\r\n      connectionState === ConnectionState.Connecting ||\r\n      !agent ||\r\n      !attributes?.[state_attribute]\r\n    ) {\r\n      return 'connecting';\r\n    } else {\r\n      return attributes[state_attribute] as AgentState;\r\n    }\r\n  }, [attributes, agent, connectionState]);\r\n\r\n  return {\r\n    agent,\r\n    state,\r\n    audioTrack,\r\n    agentTranscriptions,\r\n    agentAttributes: attributes,\r\n  };\r\n}\r\n","import { recordingStatusObservable } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport type { Room } from 'livekit-client';\r\n\r\n/**\r\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\r\n * @example\r\n * ```tsx\r\n * const isRecording = useIsRecording();\r\n * ```\r\n * @public\r\n */\r\nexport function useIsRecording(room?: Room) {\r\n  const r = useEnsureRoom(room);\r\n  const connectionState = useConnectionState(r);\r\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\r\n  const isRecording = useObservableState(observable, r.isRecording);\r\n\r\n  return isRecording;\r\n}\r\n"],"names":["useLatest","current","storedValue","React","useResizeObserver","target","callback","resizeObserver","getResizeObserver","storedCallback","didUnsubscribe","targetEl","cb","entry","observer","createResizeObserver","ticking","allEntries","callbacks","entries","obs","triggered","i","cbs","cbIndex","_resizeObserver","useSize","size","setSize","width","height","resizeCallback","useObservableState","observable","startWith","resetWhenObservableChanges","state","setState","subscription","useMediaQuery","query","getMatches","matches","setMatches","handleChange","matchMedia","useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","roomAudioPlaybackAllowedObservable","canPlayAudio","r","f","n","o","clsx","chain","args","e","mergeProps","result","props","key","a","b","useClearPinButton","dispatch","useLayoutContext","className","setupClearPinButton","useConnectionQualityIndicator","options","p","useEnsureParticipant","connectionQualityObserver","setupConnectionQualityIndicator","quality","ConnectionQuality","useConnectionState","connectionStateObserver","useDataChannel","topicOrCallback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","useDisconnectButton","connectionState","disconnect","setupDisconnectButton","ConnectionState","useFacingMode","trackReference","LocalTrackPublication","localTrack","facingMode","facingModeFromLocalTrack","useFocusToggle","trackRef","useEnsureTrackRef","layoutContext","useMaybeLayoutContext","setupFocusToggle","inFocus","isTrackReferencePinned","event","_a","_c","_b","_e","_d","useGridLayout","gridElement","trackCount","gridLayouts","GRID_LAYOUTS","layout","selectGridLayout","useIsMuted","sourceOrTrackRef","passedParticipant","ref","isMuted","setIsMuted","listener","mutedObserver","getTrackReferenceId","useIsSpeaking","participant","createIsSpeakingObserver","isProp","prop","mergePropsReactAria","cloneSingleChild","children","child","warnAboutMissingStyles","el","log","roomOptionsStringifyReplacer","val","defaultRoomProps","useLiveKitRoom","token","serverUrl","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","setRoom","shouldConnect","Room","htmlProps","setupLiveKitRoom","onSignalConnected","localP","handleMediaDeviceError","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useLocalParticipant","localParticipant","setLocalParticipant","isMicrophoneEnabled","setIsMicrophoneEnabled","isCameraEnabled","setIsCameraEnabled","lastMicrophoneError","setLastMicrophoneError","lastCameraError","setLastCameraError","isScreenShareEnabled","setIsScreenShareEnabled","microphoneTrack","setMicrophoneTrack","cameraTrack","setCameraTrack","handleUpdate","media","observeParticipantMedia","useLocalParticipantPermissions","permissionObserver","participantPermissionObserver","useMediaDeviceSelect","kind","track","requestPermissions","roomContext","useMaybeRoomContext","roomFallback","deviceObserver","createMediaDeviceObserver","devices","currentDeviceId","setCurrentDeviceId","activeDeviceObservable","setActiveMediaDevice","setupDeviceSelector","deviceId","useMediaDevices","useVisualStableUpdate","trackReferences","maxItemsOnPage","lastTrackRefs","lastMaxItemsOnPage","layoutChanged","sortedTrackRefs","sortTrackReferences","updatedTrackRefs","updatePages","error","usePagination","itemPerPage","currentPage","setCurrentPage","totalPageCount","lastItemIndex","firstItemIndex","changePage","direction","goToPage","num","tracksOnPage","useParticipantInfo","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useParticipantTile","onParticipantClick","disableSpeakingIndicator","mergedProps","setupParticipantTile","micTrack","Track","micRef","isVideoMuted","isAudioMuted","isSpeaking","useRemoteParticipants","participants","setParticipants","connectedParticipantsObserver","useParticipants","remoteParticipants","usePinnedTracks","useEnsureLayoutContext","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useStartAudio","handleStartAudioPlayback","setupStartAudio","useStartVideo","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","setupStartVideo","canPlayVideo","useSwipe","element","touchStart","touchEnd","minSwipeDistance","onTouchStart","onTouchMove","onTouchEnd","distance","isLeftSwipe","isRightSwipe","elementCopy","useChatToggle","setupChatToggle","useToken","tokenEndpoint","roomName","setToken","params","res","accessToken","useTrackMutedIndicator","mediaMutedObserver","setupTrackMutedIndicator","useTrackToggle","source","onChange","initialState","captureOptions","publishOptions","onDeviceError","userInteractionRef","toggle","pendingObserver","enabledObserver","setupMediaToggle","setupManualToggle","pending","enabled","newProps","clickHandler","evt","useTracks","sources","setTrackReferences","sources_","s","isSourceWitOptions","trackReferencesObservable","isSourcesWithOptions","requirePlaceholder","requiredPlaceholders","trackReferencesWithPlaceholders","placeholderSource","publication","placeholder","difference","setA","setB","_difference","elem","placeholderMap","sourcesThatNeedPlaceholder","sourceWithOption","sourcesOfSubscribedTracks","pub","trackSource","placeholderNeededForThisParticipant","useTrackRefBySourceOrName","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","useTrackByName","useChat","isDisconnected","setup","setupChat","chatMessages","usePersistentUserChoices","userChoices","setSettings","loadUserChoices","saveAudioInputEnabled","isEnabled","prev","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","username","saveUserChoices","useIsEncrypted","encryptionStatusObservable","useTrackVolume","trackOrTrackReference","isTrackReference","volume","setVolume","cleanup","analyser","createAudioAnalyser","bufferLength","dataArray","interval","sum","normalizeFrequencies","frequencies","normalizeDb","value","db","multibandDefaults","useMultibandTrackVolume","opts","frequencyBands","setFrequencyBands","normalizedFrequencies","chunkSize","chunks","summedVolumes","acc","waveformDefaults","useAudioWaveform","aggregateWave","timeRef","updates","bars","setBars","onUpdate","wave","filterData","v","getFFTSizeValue","update","updateWaveform","newData","x","pow2ceil","audioData","numSamples","blockSize","filteredData","blockStart","j","useParticipantTracks","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","trackSyncTimeObserver","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","addTimestampsToTranscription","trackTranscriptionObserver","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","state_attribute","useVoiceAssistant","agent","ParticipantKind","audioTrack","agentTranscriptions","attributes","useIsRecording","recordingStatusObservable"],"mappings":"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","x_google_ignoreList":[4]}