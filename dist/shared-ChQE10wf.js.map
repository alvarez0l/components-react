{"version":3,"file":"shared-ChQE10wf.js","sources":["../src/hooks/useAudioPlayback.ts","../src/hooks/useClearPinButton.ts","../src/hooks/useDataChannel.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useParticipantInfo.ts","../src/hooks/useParticipantPermissions.ts","../src/hooks/useRemoteParticipants.ts","../src/hooks/useParticipants.ts","../src/hooks/useRemoteParticipant.ts","../src/hooks/useRoomInfo.ts","../src/hooks/useSpeakingParticipants.ts","../src/hooks/useSortedParticipants.ts","../src/hooks/useToken.ts","../src/hooks/useTrackRefBySourceOrName.ts","../src/hooks/useTrackByName.ts","../src/hooks/useParticipantTracks.ts","../src/hooks/useTrackSyncTime.ts","../src/hooks/useTrackTranscription.ts","../src/hooks/useParticipantAttributes.ts","../src/hooks/useVoiceAssistant.ts","../src/hooks/useIsRecording.ts"],"sourcesContent":["import type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useObservableState } from './internal';\r\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/**\r\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\r\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\r\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\r\n * `onClick` callback to start audio playback in the current context.\r\n *\r\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\r\n * @alpha\r\n */\r\nexport function useAudioPlayback(room?: Room): {\r\n  canPlayAudio: boolean;\r\n  startAudio: () => Promise<void>;\r\n} {\r\n  const roomEnsured = useEnsureRoom(room);\r\n  const startAudio = React.useCallback(async () => {\r\n    await roomEnsured.startAudio();\r\n  }, [roomEnsured]);\r\n\r\n  const observable = React.useMemo(\r\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\r\n    [roomEnsured],\r\n  );\r\n  const { canPlayAudio } = useObservableState(observable, {\r\n    canPlayAudio: roomEnsured.canPlaybackAudio,\r\n  });\r\n\r\n  return { canPlayAudio, startAudio };\r\n}\r\n","import { setupClearPinButton } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useLayoutContext } from '../context';\r\nimport { mergeProps } from '../mergeProps';\r\nimport type { ClearPinButtonProps } from '../components';\r\n\r\n/**\r\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\r\n * or your custom implementation of it component. It adds the `onClick` handler\r\n * to signal the `LayoutContext` that the tile in focus should be cleared.\r\n * @public\r\n */\r\nexport function useClearPinButton(props: ClearPinButtonProps) {\r\n  const { state, dispatch } = useLayoutContext().pin;\r\n\r\n  const buttonProps = React.useMemo(() => {\r\n    const { className } = setupClearPinButton();\r\n    const mergedProps = mergeProps(props, {\r\n      className,\r\n      disabled: !state?.length,\r\n      onClick: () => {\r\n        if (dispatch) dispatch({ msg: 'clear_pin' });\r\n      },\r\n    });\r\n    return mergedProps;\r\n  }, [props, dispatch, state]);\r\n\r\n  return { buttonProps };\r\n}\r\n","import type { ReceivedDataMessage } from '@livekit/components-core';\r\nimport { setupDataMessageHandler } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport type { DataPublishOptions } from 'livekit-client';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\r\n  isSending: boolean;\r\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\r\n  message: ReceivedDataMessage<T> | undefined;\r\n};\r\n\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * By optionally passing a `topic`, you can narrow down which messages are returned in the messages array.\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants via the 'chat' topic.\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n * @public\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topic: T,\r\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\r\n): UseDataChannelReturnType<T>;\r\n/**\r\n * The `useDataChannel` hook returns the ability to send and receive messages.\r\n * @remarks\r\n * There is only one data channel. Passing a `topic` does not open a new data channel.\r\n * It is only used to filter out messages with no or a different `topic`.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Send messages to all participants\r\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\r\n * ```\r\n * @public\r\n */\r\nexport function useDataChannel(\r\n  onMessage?: (msg: ReceivedDataMessage) => void,\r\n): UseDataChannelReturnType;\r\n/**\r\n * @internal\r\n */\r\nexport function useDataChannel<T extends string>(\r\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\r\n  callback?: (msg: ReceivedDataMessage<T>) => void,\r\n) {\r\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\r\n\r\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\r\n  const room = useRoomContext();\r\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\r\n    () => setupDataMessageHandler(room, topic, onMessage),\r\n    [room, topic, onMessage],\r\n  );\r\n\r\n  const message = useObservableState(messageObservable, undefined);\r\n  const isSending = useObservableState(isSendingObservable, false);\r\n\r\n  return {\r\n    message,\r\n    send,\r\n    isSending,\r\n  };\r\n}\r\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\r\nimport type { DisconnectReason } from 'livekit-client';\r\nimport { Room, MediaDeviceFailure, RoomEvent } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport type { HTMLAttributes } from 'react';\r\n\r\nimport type { LiveKitRoomProps } from '../components';\r\nimport { mergeProps } from '../mergeProps';\r\nimport { roomOptionsStringifyReplacer } from '../utils';\r\n\r\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\r\n  connect: true,\r\n  audio: false,\r\n  video: false,\r\n};\r\n\r\n/**\r\n * The `useLiveKitRoom` hook is used to implement the `LiveKitRoom` or your custom implementation of it.\r\n * It returns a `Room` instance and HTML props that should be applied to the root element of the component.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { room, htmlProps } = useLiveKitRoom();\r\n * return <div {...htmlProps}>...</div>;\r\n * ```\r\n * @public\r\n */\r\nexport function useLiveKitRoom<T extends HTMLElement>(\r\n  props: LiveKitRoomProps,\r\n): {\r\n  room: Room | undefined;\r\n  htmlProps: HTMLAttributes<T>;\r\n} {\r\n  const {\r\n    token,\r\n    serverUrl,\r\n    options,\r\n    room: passedRoom,\r\n    connectOptions,\r\n    connect,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onConnected,\r\n    onDisconnected,\r\n    onError,\r\n    onMediaDeviceFailure,\r\n    onEncryptionError,\r\n    simulateParticipants,\r\n    ...rest\r\n  } = { ...defaultRoomProps, ...props };\r\n  if (options && passedRoom) {\r\n    log.warn(\r\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\r\n    );\r\n  }\r\n\r\n  const [room, setRoom] = React.useState<Room | undefined>();\r\n\r\n  const shouldConnect = React.useRef(connect);\r\n\r\n  React.useEffect(() => {\r\n    setRoom(passedRoom ?? new Room(options));\r\n  }, [passedRoom, JSON.stringify(options, roomOptionsStringifyReplacer)]);\r\n\r\n  const htmlProps = React.useMemo(() => {\r\n    const { className } = setupLiveKitRoom();\r\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\r\n  }, [rest]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    const onSignalConnected = () => {\r\n      const localP = room.localParticipant;\r\n\r\n      log.debug('trying to publish local tracks');\r\n      Promise.all([\r\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\r\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\r\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\r\n      ]).catch((e) => {\r\n        log.warn(e);\r\n        onError?.(e as Error);\r\n      });\r\n    };\r\n\r\n    const handleMediaDeviceError = (e: Error) => {\r\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\r\n      onMediaDeviceFailure?.(mediaDeviceFailure);\r\n    };\r\n    const handleEncryptionError = (e: Error) => {\r\n      onEncryptionError?.(e);\r\n    };\r\n    const handleDisconnected = (reason?: DisconnectReason) => {\r\n      onDisconnected?.(reason);\r\n    };\r\n    const handleConnected = () => {\r\n      onConnected?.();\r\n    };\r\n\r\n    room\r\n      .on(RoomEvent.SignalConnected, onSignalConnected)\r\n      .on(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n      .on(RoomEvent.EncryptionError, handleEncryptionError)\r\n      .on(RoomEvent.Disconnected, handleDisconnected)\r\n      .on(RoomEvent.Connected, handleConnected);\r\n\r\n    return () => {\r\n      room\r\n        .off(RoomEvent.SignalConnected, onSignalConnected)\r\n        .off(RoomEvent.MediaDevicesError, handleMediaDeviceError)\r\n        .off(RoomEvent.EncryptionError, handleEncryptionError)\r\n        .off(RoomEvent.Disconnected, handleDisconnected)\r\n        .off(RoomEvent.Connected, handleConnected);\r\n    };\r\n  }, [\r\n    room,\r\n    audio,\r\n    video,\r\n    screen,\r\n    onError,\r\n    onEncryptionError,\r\n    onMediaDeviceFailure,\r\n    onConnected,\r\n    onDisconnected,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n\r\n    if (simulateParticipants) {\r\n      room.simulateParticipants({\r\n        participants: {\r\n          count: simulateParticipants,\r\n        },\r\n        publish: {\r\n          audio: true,\r\n          useRealTracks: true,\r\n        },\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (connect) {\r\n      shouldConnect.current = true;\r\n      log.debug('connecting');\r\n      if (!token) {\r\n        log.debug('no token yet');\r\n        return;\r\n      }\r\n      if (!serverUrl) {\r\n        log.warn('no livekit url provided');\r\n        onError?.(Error('no livekit url provided'));\r\n        return;\r\n      }\r\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\r\n        log.warn(e);\r\n        if (shouldConnect.current === true) {\r\n          onError?.(e as Error);\r\n        }\r\n      });\r\n    } else {\r\n      log.debug('disconnecting because connect is false');\r\n      shouldConnect.current = false;\r\n      room.disconnect();\r\n    }\r\n  }, [\r\n    connect,\r\n    token,\r\n    JSON.stringify(connectOptions),\r\n    room,\r\n    onError,\r\n    serverUrl,\r\n    simulateParticipants,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    if (!room) return;\r\n    return () => {\r\n      log.info('disconnecting on onmount');\r\n      room.disconnect();\r\n    };\r\n  }, [room]);\r\n\r\n  return { room, htmlProps };\r\n}\r\n","import { participantInfoObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { identity, name, metadata } = useParticipantInfo({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantInfoOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\r\n  let p = useMaybeParticipantContext();\r\n  if (props.participant) {\r\n    p = props.participant;\r\n  }\r\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\r\n  const { identity, name, metadata } = useObservableState(infoObserver, {\r\n    name: p?.name,\r\n    identity: p?.identity,\r\n    metadata: p?.metadata,\r\n  });\r\n\r\n  return { identity, name, metadata };\r\n}\r\n","import { participantPermissionObserver } from '@livekit/components-core';\r\nimport type { ParticipantPermission } from '@livekit/protocol';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useObservableState } from './internal/useObservableState';\r\n\r\n/**\r\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\r\n *\r\n * @example\r\n * ```tsx\r\n * const permissions = useParticipantPermissions({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantPermissionsOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantPermissions(\r\n  options: UseParticipantPermissionsOptions = {},\r\n): ParticipantPermission | undefined {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\r\n  const permissions = useObservableState(permissionObserver, p.permissions);\r\n  return permissions;\r\n}\r\n","import { connectedParticipantsObserver } from '@livekit/components-core';\r\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useRemoteParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\r\n\r\n  React.useEffect(() => {\r\n    const listener = connectedParticipantsObserver(room, {\r\n      additionalRoomEvents: options.updateOnlyOn,\r\n    }).subscribe(setParticipants);\r\n    return () => listener.unsubscribe();\r\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\r\n  return participants;\r\n}\r\n","import type { Room, RoomEvent } from 'livekit-client';\r\nimport { useLocalParticipant } from './useLocalParticipant';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UseParticipantsOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\r\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\r\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\r\n   */\r\n  updateOnlyOn?: RoomEvent[];\r\n  /**\r\n   * The room to use. If not provided, the hook will use the room from the context.\r\n   */\r\n  room?: Room;\r\n}\r\n\r\n/**\r\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participants = useParticipants();\r\n * <ParticipantLoop participants={participants}>\r\n *  <ParticipantName />\r\n * </ParticipantLoop>\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipants(options: UseParticipantsOptions = {}) {\r\n  const remoteParticipants = useRemoteParticipants(options);\r\n  const { localParticipant } = useLocalParticipant(options);\r\n\r\n  return React.useMemo(\r\n    () => [localParticipant, ...remoteParticipants],\r\n    [localParticipant, remoteParticipants],\r\n  );\r\n}\r\n","import {\r\n  type ParticipantIdentifier,\r\n  connectedParticipantObserver,\r\n  participantByIdentifierObserver,\r\n} from '@livekit/components-core';\r\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\n\r\n/** @public */\r\nexport interface UseRemoteParticipantOptions {\r\n  /**\r\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\r\n   */\r\n  updateOnlyOn?: ParticipantEvent[];\r\n}\r\n\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identifier: ParticipantIdentifier,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\n/**\r\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\r\n * @remarks\r\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\r\n *\r\n * @example\r\n * ```tsx\r\n * const participant = useRemoteParticipant('Russ');\r\n * ```\r\n * @public\r\n */\r\nexport function useRemoteParticipant(\r\n  identity: string,\r\n  options?: UseRemoteParticipantOptions,\r\n): RemoteParticipant | undefined;\r\nexport function useRemoteParticipant(\r\n  identityOrIdentifier: string | ParticipantIdentifier,\r\n  options: UseRemoteParticipantOptions = {},\r\n): RemoteParticipant | undefined {\r\n  const room = useRoomContext();\r\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\r\n\r\n  const observable = React.useMemo(() => {\r\n    if (typeof identityOrIdentifier === 'string') {\r\n      return connectedParticipantObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    } else {\r\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\r\n        additionalEvents: updateOnlyOn,\r\n      });\r\n    }\r\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\r\n\r\n  // Using `wrapperParticipant` to ensure a new object reference,\r\n  // triggering a re-render when the participant events fire.\r\n  const [participantWrapper, setParticipantWrapper] = React.useState({\r\n    p: undefined as RemoteParticipant | undefined,\r\n  });\r\n  React.useEffect(() => {\r\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\r\n    return () => listener.unsubscribe();\r\n  }, [observable]);\r\n\r\n  return participantWrapper.p;\r\n}\r\n","import { roomInfoObserver } from '@livekit/components-core';\r\nimport type { Room } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\r\n * @remarks\r\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { name, metadata } = useRoomInfo();\r\n * ```\r\n * @public\r\n */\r\nexport interface UseRoomInfoOptions {\r\n  room?: Room;\r\n}\r\n\r\n/** @public */\r\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\r\n  const room = useEnsureRoom(options.room);\r\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\r\n  const { name, metadata } = useObservableState(infoObserver, {\r\n    name: room.name,\r\n    metadata: room.metadata,\r\n  });\r\n\r\n  return { name, metadata };\r\n}\r\n","import { activeSpeakerObserver } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useRoomContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\r\n *\r\n * @example\r\n * ```tsx\r\n * const activeSpeakers = useSpeakingParticipants();\r\n * ```\r\n * @public\r\n */\r\nexport function useSpeakingParticipants() {\r\n  const room = useRoomContext();\r\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\r\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\r\n  return activeSpeakers;\r\n}\r\n","import { sortParticipants } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\r\n\r\n/**\r\n * The `useSortedParticipants` hook returns the participants sorted by importance.\r\n * @public\r\n */\r\nexport function useSortedParticipants(participants: Array<Participant>) {\r\n  const [sortedParticipants, setSortedParticipants] = React.useState(\r\n    sortParticipants(participants),\r\n  );\r\n  const activeSpeakers = useSpeakingParticipants();\r\n\r\n  React.useEffect(() => {\r\n    setSortedParticipants(sortParticipants(participants));\r\n  }, [activeSpeakers, participants]);\r\n  return sortedParticipants;\r\n}\r\n","import { log } from '@livekit/components-core';\r\nimport * as React from 'react';\r\n\r\n/** @public */\r\nexport interface UserInfo {\r\n  identity?: string;\r\n  name?: string;\r\n  metadata?: string;\r\n}\r\n\r\n/** @public */\r\nexport interface UseTokenOptions {\r\n  userInfo?: UserInfo;\r\n}\r\n\r\n/**\r\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\r\n *\r\n * @example\r\n * ```tsx\r\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\r\n * ```\r\n * @public */\r\nexport function useToken(\r\n  tokenEndpoint: string | undefined,\r\n  roomName: string,\r\n  options: UseTokenOptions = {},\r\n) {\r\n  const [token, setToken] = React.useState<string | undefined>(undefined);\r\n\r\n  React.useEffect(() => {\r\n    if (tokenEndpoint === undefined) {\r\n      throw Error('token endpoint needs to be defined');\r\n    }\r\n    if (options.userInfo?.identity === undefined) {\r\n      return;\r\n    }\r\n    const tokenFetcher = async () => {\r\n      log.debug('fetching token');\r\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\r\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\r\n      if (!res.ok) {\r\n        log.error(\r\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\r\n        );\r\n        return;\r\n      }\r\n      const { accessToken } = await res.json();\r\n      setToken(accessToken);\r\n    };\r\n    tokenFetcher();\r\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\r\n  return token;\r\n}\r\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\r\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { Track } from 'livekit-client';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackRefBySourceOrName(\r\n  source: TrackSource<Track.Source>,\r\n): TrackReferenceOrPlaceholder {\r\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\r\n\r\n  const { trackObserver } = React.useMemo(() => {\r\n    return setupMediaTrack(source);\r\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\r\n\r\n  React.useEffect(() => {\r\n    const subscription = trackObserver.subscribe((publication) => {\r\n      setPublication(publication);\r\n    });\r\n    return () => subscription?.unsubscribe();\r\n  }, [trackObserver]);\r\n\r\n  return {\r\n    participant: source.participant,\r\n    source: source.source ?? Track.Source.Unknown,\r\n    publication,\r\n  };\r\n}\r\n","import type { Participant } from 'livekit-client';\r\nimport { useEnsureParticipant } from '../context';\r\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\r\n\r\n/**\r\n * This function `useTrackByName` allows you to access a track by referencing its track name.\r\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\r\n * for both a passed participant argument and, if not available, a valid participant context.\r\n *\r\n * @public\r\n */\r\nexport function useTrackByName(name: string, participant?: Participant) {\r\n  const p = useEnsureParticipant(participant);\r\n  return useTrackRefBySourceOrName({ name, participant: p });\r\n}\r\n","import * as React from 'react';\r\nimport type { TrackReference } from '@livekit/components-core';\r\nimport { participantTracksObservable } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\nimport type { Track } from 'livekit-client';\r\nimport { useMaybeParticipantContext, useRoomContext } from '../context';\r\n\r\n/**\r\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\r\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\r\n * @public\r\n */\r\nexport function useParticipantTracks(\r\n  sources: Track.Source[],\r\n  participantIdentity?: string,\r\n): TrackReference[] {\r\n  const room = useRoomContext();\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = participantIdentity\r\n    ? room.getParticipantByIdentity(participantIdentity)\r\n    : participantContext;\r\n  const observable = React.useMemo(\r\n    () => (p ? participantTracksObservable(p, { sources }) : undefined),\r\n    [p?.sid, p?.identity, JSON.stringify(sources)],\r\n  );\r\n\r\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\r\n\r\n  return trackRefs;\r\n}\r\n","import * as React from 'react';\r\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\r\n  const observable = React.useMemo(\r\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\r\n    [ref?.publication?.track],\r\n  );\r\n  return useObservableState(observable, {\r\n    timestamp: Date.now(),\r\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\r\n  });\r\n}\r\n","import {\r\n  type ReceivedTranscriptionSegment,\r\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\r\n  dedupeSegments,\r\n  // getActiveTranscriptionSegments,\r\n  getTrackReferenceId,\r\n  trackTranscriptionObserver,\r\n  type TrackReferenceOrPlaceholder,\r\n  // didActiveSegmentsChange,\r\n} from '@livekit/components-core';\r\nimport type { TranscriptionSegment } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useTrackSyncTime } from './useTrackSyncTime';\r\n\r\n/**\r\n * @alpha\r\n */\r\nexport interface TrackTranscriptionOptions {\r\n  /**\r\n   * how many transcription segments should be buffered in state\r\n   * @defaultValue 100\r\n   */\r\n  bufferSize?: number;\r\n  /**\r\n   * optional callback for retrieving newly incoming transcriptions only\r\n   */\r\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\r\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\r\n  // maxAge?: number;\r\n}\r\n\r\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\r\n  bufferSize: 100,\r\n  // maxAge: 2_000,\r\n} as const satisfies TrackTranscriptionOptions;\r\n\r\n/**\r\n * @returns An object consisting of `segments` with maximum length of opts.windowLength and `activeSegments` that are valid for the current track timestamp\r\n * @alpha\r\n */\r\nexport function useTrackTranscription(\r\n  trackRef: TrackReferenceOrPlaceholder | undefined,\r\n  options?: TrackTranscriptionOptions,\r\n) {\r\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\r\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\r\n  // const [activeSegments, setActiveSegments] = React.useState<Array<ReceivedTranscriptionSegment>>(\r\n  //   [],\r\n  // );\r\n  // const prevActiveSegments = React.useRef<ReceivedTranscriptionSegment[]>([]);\r\n  const syncTimestamps = useTrackSyncTime(trackRef);\r\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\r\n    opts.onTranscription?.(newSegments);\r\n    setSegments((prevSegments) =>\r\n      dedupeSegments(\r\n        prevSegments,\r\n        // when first receiving a segment, add the current media timestamp to it\r\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\r\n        opts.bufferSize,\r\n      ),\r\n    );\r\n  };\r\n  React.useEffect(() => {\r\n    if (!trackRef?.publication) {\r\n      return;\r\n    }\r\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\r\n      handleSegmentMessage(...evt);\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\r\n\r\n  // React.useEffect(() => {\r\n  //   if (syncTimestamps) {\r\n  //     const newActiveSegments = getActiveTranscriptionSegments(\r\n  //       segments,\r\n  //       syncTimestamps,\r\n  //       opts.maxAge,\r\n  //     );\r\n  //     // only update active segment array if content actually changed\r\n  //     if (didActiveSegmentsChange(prevActiveSegments.current, newActiveSegments)) {\r\n  //       setActiveSegments(newActiveSegments);\r\n  //       prevActiveSegments.current = newActiveSegments;\r\n  //     }\r\n  //   }\r\n  // }, [syncTimestamps, segments, opts.maxAge]);\r\n\r\n  return { segments };\r\n}\r\n","import { participantAttributesObserver } from '@livekit/components-core';\r\nimport type { Participant } from 'livekit-client';\r\nimport * as React from 'react';\r\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\r\nimport { useObservableState } from './internal';\r\n\r\n/**\r\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\r\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const { attributes } = useParticipantAttributes({ participant });\r\n * ```\r\n * @public\r\n */\r\nexport interface UseParticipantAttributesOptions {\r\n  participant?: Participant;\r\n}\r\n\r\n/** @public */\r\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\r\n  const participantContext = useMaybeParticipantContext();\r\n  const p = props.participant ?? participantContext;\r\n  const attributeObserver = React.useMemo(\r\n    // weird typescript constraint\r\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\r\n    [p],\r\n  );\r\n  const attributeState = useObservableState(attributeObserver, {\r\n    attributes: p?.attributes,\r\n  });\r\n\r\n  return attributeState;\r\n}\r\n\r\n/**\r\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\r\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\r\n *\r\n * @example\r\n * ```tsx\r\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\r\n * ```\r\n * @public\r\n */\r\nexport function useParticipantAttribute(\r\n  attributeKey: string,\r\n  options: UseParticipantAttributesOptions = {},\r\n) {\r\n  const p = useEnsureParticipant(options.participant);\r\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\r\n\r\n  React.useEffect(() => {\r\n    if (!p) {\r\n      return;\r\n    }\r\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\r\n      if (val.changed[attributeKey] !== undefined) {\r\n        setAttribute(val.attributes[attributeKey]);\r\n      }\r\n    });\r\n    return () => {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [p, attributeKey]);\r\n\r\n  return attribute;\r\n}\r\n","import * as React from 'react';\r\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\r\nimport type { RemoteParticipant } from 'livekit-client';\r\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\r\nimport { useRemoteParticipants } from './useRemoteParticipants';\r\nimport { useParticipantTracks } from './useParticipantTracks';\r\nimport { useTrackTranscription } from './useTrackTranscription';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport { useParticipantAttributes } from './useParticipantAttributes';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport type AgentState =\r\n  | 'disconnected'\r\n  | 'connecting'\r\n  | 'initializing'\r\n  | 'listening'\r\n  | 'thinking'\r\n  | 'speaking';\r\n\r\n/**\r\n * @beta\r\n */\r\nexport interface VoiceAssistant {\r\n  agent: RemoteParticipant | undefined;\r\n  state: AgentState;\r\n  audioTrack: TrackReference | undefined;\r\n  agentTranscriptions: ReceivedTranscriptionSegment[];\r\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\r\n}\r\n\r\nconst state_attribute = 'lk.agent.state';\r\n\r\n/**\r\n * This hook looks for the first agent-participant in the room.\r\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\r\n * @example\r\n * ```tsx\r\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\r\n * ```\r\n * @beta\r\n */\r\nexport function useVoiceAssistant(): VoiceAssistant {\r\n  const agent = useRemoteParticipants().find((p) => p.kind === ParticipantKind.AGENT);\r\n  const audioTrack = useParticipantTracks([Track.Source.Microphone], agent?.identity)[0];\r\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\r\n  const connectionState = useConnectionState();\r\n  const { attributes } = useParticipantAttributes({ participant: agent });\r\n\r\n  const state: AgentState = React.useMemo(() => {\r\n    if (connectionState === ConnectionState.Disconnected) {\r\n      return 'disconnected';\r\n    } else if (\r\n      connectionState === ConnectionState.Connecting ||\r\n      !agent ||\r\n      !attributes?.[state_attribute]\r\n    ) {\r\n      return 'connecting';\r\n    } else {\r\n      return attributes[state_attribute] as AgentState;\r\n    }\r\n  }, [attributes, agent, connectionState]);\r\n\r\n  return {\r\n    agent,\r\n    state,\r\n    audioTrack,\r\n    agentTranscriptions,\r\n    agentAttributes: attributes,\r\n  };\r\n}\r\n","import { recordingStatusObservable } from '@livekit/components-core';\r\nimport * as React from 'react';\r\nimport { useEnsureRoom } from '../context';\r\nimport { useObservableState } from './internal';\r\nimport { useConnectionState } from './useConnectionStatus';\r\nimport type { Room } from 'livekit-client';\r\n\r\n/**\r\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\r\n * @example\r\n * ```tsx\r\n * const isRecording = useIsRecording();\r\n * ```\r\n * @public\r\n */\r\nexport function useIsRecording(room?: Room) {\r\n  const r = useEnsureRoom(room);\r\n  const connectionState = useConnectionState(r);\r\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\r\n  const isRecording = useObservableState(observable, r.isRecording);\r\n\r\n  return isRecording;\r\n}\r\n"],"names":["useAudioPlayback","room","roomEnsured","useEnsureRoom","startAudio","React","observable","roomAudioPlaybackAllowedObservable","canPlayAudio","useObservableState","useClearPinButton","props","state","dispatch","useLayoutContext","className","setupClearPinButton","mergeProps","useDataChannel","topicOrCallback","callback","onMessage","topic","useRoomContext","send","messageObservable","isSendingObservable","setupDataMessageHandler","message","isSending","defaultRoomProps","useLiveKitRoom","token","serverUrl","options","passedRoom","connectOptions","connect","audio","video","screen","onConnected","onDisconnected","onError","onMediaDeviceFailure","onEncryptionError","simulateParticipants","rest","log","setRoom","shouldConnect","Room","roomOptionsStringifyReplacer","htmlProps","setupLiveKitRoom","onSignalConnected","localP","e","handleMediaDeviceError","mediaDeviceFailure","MediaDeviceFailure","handleEncryptionError","handleDisconnected","reason","handleConnected","RoomEvent","useParticipantInfo","p","useMaybeParticipantContext","infoObserver","participantInfoObserver","identity","name","metadata","useParticipantPermissions","useEnsureParticipant","permissionObserver","participantPermissionObserver","useRemoteParticipants","participants","setParticipants","listener","connectedParticipantsObserver","useParticipants","remoteParticipants","localParticipant","useLocalParticipant","useRemoteParticipant","identityOrIdentifier","updateOnlyOn","connectedParticipantObserver","participantByIdentifierObserver","participantWrapper","setParticipantWrapper","useRoomInfo","roomInfoObserver","useSpeakingParticipants","speakerObserver","activeSpeakerObserver","useSortedParticipants","sortedParticipants","setSortedParticipants","sortParticipants","activeSpeakers","useToken","tokenEndpoint","roomName","setToken","_a","params","res","accessToken","useTrackRefBySourceOrName","source","publication","setPublication","getTrackByIdentifier","trackObserver","setupMediaTrack","subscription","Track","useTrackByName","participant","useParticipantTracks","sources","participantIdentity","participantContext","participantTracksObservable","useTrackSyncTime","ref","trackSyncTimeObserver","_c","_b","TRACK_TRANSCRIPTION_DEFAULTS","useTrackTranscription","trackRef","opts","segments","setSegments","syncTimestamps","handleSegmentMessage","newSegments","prevSegments","dedupeSegments","s","addTimestampsToTranscription","trackTranscriptionObserver","evt","getTrackReferenceId","useParticipantAttributes","attributeObserver","participantAttributesObserver","useParticipantAttribute","attributeKey","attribute","setAttribute","val","state_attribute","useVoiceAssistant","agent","ParticipantKind","audioTrack","agentTranscriptions","connectionState","useConnectionState","attributes","ConnectionState","useIsRecording","r","recordingStatusObservable"],"mappings":"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"}